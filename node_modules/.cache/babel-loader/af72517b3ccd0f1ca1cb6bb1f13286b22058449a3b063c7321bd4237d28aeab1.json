{"ast":null,"code":"import axios from 'axios';\nconst OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';\n\n// You'll need to set this in your environment variables\nconst API_KEY = process.env.REACT_APP_OPENAI_API_KEY;\n\n/**\n * Classify feedback text into themes using OpenAI\n * @param {string} feedbackText - The feedback text to classify\n * @returns {Promise<Object>} - An object containing the theme and confidence\n */\nexport const classifyFeedback = async feedbackText => {\n  try {\n    // Check if the API key is available\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback classification.');\n      return mockClassifyFeedback(feedbackText);\n    }\n    const response = await axios.post('https://api.openai.com/v1/chat/completions', {\n      model: 'gpt-3.5-turbo',\n      messages: [{\n        role: 'system',\n        content: 'You are an assistant that categorizes user feedback into a single theme. Choose the most appropriate theme from: Performance, Usability, Design, Functionality, Data Visualization, Mobile Experience, Error Handling, or create a new appropriate theme if none of these fit well.'\n      }, {\n        role: 'user',\n        content: `Categorize this feedback into a single theme: \"${feedbackText}\". Respond with a JSON object with the format {\"theme\": \"ThemeName\", \"confidence\": 0.X} where confidence is a number between 0 and 1.`\n      }],\n      temperature: 0.3,\n      max_tokens: 100\n    }, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`\n      }\n    });\n\n    // Parse the response to extract the theme\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\{.*\\}/s);\n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse theme from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error classifying feedback with OpenAI:', error);\n    // Fall back to keyword-based classification\n    return mockClassifyFeedback(feedbackText);\n  }\n};\n\n/**\n * Process a batch of feedback texts to extract themes using OpenAI\n * @param {Array} feedbackItems - Array of feedback objects\n * @returns {Promise<Object>} - Mapping of feedback IDs to themes\n */\nexport const batchClassifyFeedback = async feedbackItems => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback classification.');\n      return fallbackBatchClassify(feedbackItems);\n    }\n\n    // Prepare the batch prompt\n    const feedbackTexts = feedbackItems.map((item, index) => `Feedback ${index + 1}: \"${item.text}\"`).join('\\n\\n');\n    const response = await axios.post('https://api.openai.com/v1/chat/completions', {\n      model: 'gpt-3.5-turbo-16k',\n      messages: [{\n        role: 'system',\n        content: 'You are an assistant that categorizes multiple pieces of user feedback into themes. Choose appropriate themes from: Performance, Usability, Design, Functionality, Data Visualization, Mobile Experience, Error Handling, or create new themes if needed.'\n      }, {\n        role: 'user',\n        content: `Categorize each of these feedback items into a single theme:\\n\\n${feedbackTexts}\\n\\nRespond with a JSON array with the format [{\"feedbackIndex\": 1, \"theme\": \"ThemeName\"}, {\"feedbackIndex\": 2, \"theme\": \"ThemeName\"}, ...] for each feedback item.`\n      }],\n      temperature: 0.3,\n      max_tokens: 2000\n    }, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`\n      }\n    });\n\n    // Parse the response to extract the themes\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\[\\s*\\{.*\\}\\s*\\]/s);\n    if (match) {\n      const results = JSON.parse(match[0]);\n\n      // Create a mapping of feedback ID to theme\n      const themeMap = {};\n      results.forEach(result => {\n        const feedbackItem = feedbackItems[result.feedbackIndex - 1];\n        if (feedbackItem) {\n          themeMap[feedbackItem.id] = result.theme;\n        }\n      });\n      return themeMap;\n    } else {\n      throw new Error('Could not parse themes from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error batch classifying feedback with OpenAI:', error);\n    // Fall back to individual keyword-based classification\n    return fallbackBatchClassify(feedbackItems);\n  }\n};\n\n/**\n * Generate feature ideas based on feedback themes\n * @param {string} theme - The theme to generate feature ideas for\n * @param {Array} relatedFeedback - Array of related feedback texts\n * @returns {Promise<Array>} - Array of feature ideas\n */\nexport const generateFeatureIdeas = async (theme, relatedFeedback = []) => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback feature generation.');\n      return mockGenerateFeatureIdeas(theme);\n    }\n\n    // Prepare the context with related feedback\n    let feedbackContext = '';\n    if (relatedFeedback && relatedFeedback.length > 0) {\n      feedbackContext = `Here are some examples of user feedback related to this theme:\\n\\n${relatedFeedback.slice(0, 5).join('\\n\\n')}`;\n    }\n    const response = await axios.post('https://api.openai.com/v1/chat/completions', {\n      model: 'gpt-3.5-turbo',\n      messages: [{\n        role: 'system',\n        content: 'You are a product manager who generates practical feature ideas based on user feedback themes.'\n      }, {\n        role: 'user',\n        content: `Generate 2-3 feature ideas to address the \"${theme}\" theme in our application. ${feedbackContext}\\n\\nRespond with a JSON array of features with the format [{\"name\": \"Feature Name\", \"description\": \"Brief description\", \"priority\": \"High/Medium/Low\"}]`\n      }],\n      temperature: 0.7,\n      max_tokens: 500\n    }, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`\n      }\n    });\n\n    // Parse the response to extract the feature ideas\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\[\\s*\\{.*\\}\\s*\\]/s);\n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse feature ideas from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error generating feature ideas with OpenAI:', error);\n    // Fall back to mock feature generation\n    return mockGenerateFeatureIdeas(theme);\n  }\n};\n\n/**\n * Analyze sentiment of feedback text using OpenAI\n * @param {string} text - The feedback text to analyze\n * @returns {Promise<Object>} - An object containing sentiment and confidence\n */\nexport const analyzeSentiment = async text => {\n  try {\n    // Log the text being analyzed for debugging\n    console.log(\"Analyzing sentiment for:\", text);\n\n    // Create a more specific prompt for the OpenAI API\n    const response = await fetch('/api/analyze-sentiment', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        text,\n        // Add specific instructions to ensure accurate classification\n        instructions: `\n          Analyze the sentiment of this user feedback for a software application.\n          \n          Guidelines:\n          - Classify as \"Negative\" if the feedback expresses any problems, complaints, frustrations, \n            or suggestions for fixing issues, even if politely phrased\n          - Classify as \"Positive\" only if the feedback is clearly expressing satisfaction or praise\n          - Use \"Neutral\" only for purely factual statements without emotional content\n          \n          Important: Any mention of bugs, crashes, difficulties, confusion, or feature requests \n          should be classified as \"Negative\" as they indicate user pain points.\n          \n          Return only \"Positive\", \"Negative\", or \"Neutral\".\n        `\n      })\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to analyze sentiment: ${response.status}`);\n    }\n    const data = await response.json();\n    console.log(\"Sentiment analysis result:\", data);\n\n    // Ensure we have a valid sentiment value\n    if (!data.sentiment || !['Positive', 'Negative', 'Neutral'].includes(data.sentiment)) {\n      console.warn(\"Invalid sentiment received:\", data.sentiment);\n      // Default to a more cautious classification if the API returns something unexpected\n      return {\n        sentiment: \"Negative\"\n      };\n    }\n    return {\n      sentiment: data.sentiment\n    };\n  } catch (error) {\n    console.error('Error analyzing sentiment:', error);\n    // In case of error, default to Negative to be cautious\n    return {\n      sentiment: \"Negative\"\n    };\n  }\n};\n\n/**\n * Batch analyze sentiment for multiple feedback texts\n * @param {Array} feedbackItems - Array of feedback objects\n * @returns {Promise<Object>} - Mapping of feedback IDs to sentiment\n */\nexport const batchAnalyzeSentiment = async feedbackItems => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback sentiment analysis.');\n      return fallbackBatchSentiment(feedbackItems);\n    }\n\n    // Prepare the batch prompt\n    const feedbackTexts = feedbackItems.map((item, index) => `Feedback ${index + 1}: \"${item.text}\"`).join('\\n\\n');\n    const response = await axios.post('https://api.openai.com/v1/chat/completions', {\n      model: 'gpt-3.5-turbo-16k',\n      messages: [{\n        role: 'system',\n        content: 'You are an assistant that analyzes the sentiment of multiple pieces of user feedback. Classify each as Positive, Negative, or Neutral.'\n      }, {\n        role: 'user',\n        content: `Analyze the sentiment of each of these feedback items:\\n\\n${feedbackTexts}\\n\\nRespond with a JSON array with the format [{\"feedbackIndex\": 1, \"sentiment\": \"Positive/Negative/Neutral\"}, {\"feedbackIndex\": 2, \"sentiment\": \"Positive/Negative/Neutral\"}, ...] for each feedback item.`\n      }],\n      temperature: 0.3,\n      max_tokens: 2000\n    }, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`\n      }\n    });\n\n    // Parse the response to extract the sentiments\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\[\\s*\\{.*\\}\\s*\\]/s);\n    if (match) {\n      const results = JSON.parse(match[0]);\n\n      // Create a mapping of feedback ID to sentiment\n      const sentimentMap = {};\n      results.forEach(result => {\n        const feedbackItem = feedbackItems[result.feedbackIndex - 1];\n        if (feedbackItem) {\n          sentimentMap[feedbackItem.id] = result.sentiment;\n        }\n      });\n      return sentimentMap;\n    } else {\n      throw new Error('Could not parse sentiments from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error batch analyzing sentiment with OpenAI:', error);\n    return fallbackBatchSentiment(feedbackItems);\n  }\n};\n\n/**\n * Fallback function for batch classification\n * @param {Array} feedbackItems - Array of feedback objects\n * @returns {Object} - Mapping of feedback IDs to themes\n */\nconst fallbackBatchClassify = feedbackItems => {\n  const themeMap = {};\n  feedbackItems.forEach(item => {\n    const result = mockClassifyFeedback(item.text);\n    themeMap[item.id] = result.theme;\n  });\n  return themeMap;\n};\n\n/**\n * Mock function for keyword-based theme classification (used as fallback)\n * @param {string} text - The feedback text to classify\n * @returns {Object} - An object containing the theme\n */\nconst mockClassifyFeedback = text => {\n  const lowerText = text.toLowerCase();\n  if (lowerText.includes('crash') || lowerText.includes('error') || lowerText.includes('bug')) {\n    return {\n      theme: 'Error Handling'\n    };\n  } else if (lowerText.includes('slow') || lowerText.includes('performance') || lowerText.includes('timeout') || lowerText.includes('load')) {\n    return {\n      theme: 'Performance'\n    };\n  } else if (lowerText.includes('mobile') || lowerText.includes('app') || lowerText.includes('phone')) {\n    return {\n      theme: 'Mobile Experience'\n    };\n  } else if (lowerText.includes('ui') || lowerText.includes('interface') || lowerText.includes('design') || lowerText.includes('layout') || lowerText.includes('look')) {\n    return {\n      theme: 'Design'\n    };\n  } else if (lowerText.includes('report') || lowerText.includes('dashboard')) {\n    return {\n      theme: 'Data Visualization'\n    };\n  } else if (lowerText.includes('export') || lowerText.includes('excel') || lowerText.includes('pdf')) {\n    return {\n      theme: 'Data Export'\n    };\n  } else if (lowerText.includes('search') || lowerText.includes('filter') || lowerText.includes('find')) {\n    return {\n      theme: 'Navigation'\n    };\n  } else if (lowerText.includes('easy') || lowerText.includes('difficult') || lowerText.includes('confusing') || lowerText.includes('intuitive') || lowerText.includes('user-friendly')) {\n    return {\n      theme: 'Usability'\n    };\n  } else if (lowerText.includes('feature') || lowerText.includes('function') || lowerText.includes('capability')) {\n    return {\n      theme: 'Functionality'\n    };\n  }\n  return {\n    theme: 'General Feedback'\n  };\n};\n\n/**\n * Mock function for feature idea generation (used as fallback)\n * @param {string} theme - The theme to generate feature ideas for\n * @returns {Array} - Array of feature ideas\n */\nconst mockGenerateFeatureIdeas = theme => {\n  switch (theme) {\n    case 'Error Handling':\n      return [{\n        name: 'Intelligent Error Recovery',\n        description: 'Automatically recover from common errors without user intervention',\n        priority: 'High'\n      }, {\n        name: 'User-Friendly Error Messages',\n        description: 'Replace technical error messages with clear action items for users',\n        priority: 'Medium'\n      }];\n    case 'Performance':\n      return [{\n        name: 'Optimized Data Loading',\n        description: 'Implement progressive loading and caching for faster dashboard performance',\n        priority: 'High'\n      }, {\n        name: 'Background Processing',\n        description: 'Move heavy calculations to background threads to keep UI responsive',\n        priority: 'Medium'\n      }];\n    case 'Design':\n      return [{\n        name: 'Redesigned Interface',\n        description: 'Streamline UI with modern design principles and improved visual hierarchy',\n        priority: 'Medium'\n      }, {\n        name: 'Customizable Themes',\n        description: 'Allow users to personalize the interface with color themes and layouts',\n        priority: 'Low'\n      }];\n    default:\n      return [{\n        name: `${theme} Improvements`,\n        description: `Address user feedback related to ${theme.toLowerCase()}`,\n        priority: 'Medium'\n      }, {\n        name: 'User Experience Enhancement',\n        description: 'General improvements based on feedback analysis',\n        priority: 'Medium'\n      }];\n  }\n};\n\n/**\n * Fallback function for batch sentiment analysis\n */\nconst fallbackBatchSentiment = feedbackItems => {\n  const sentimentMap = {};\n  feedbackItems.forEach(item => {\n    const result = mockAnalyzeSentiment(item.text);\n    sentimentMap[item.id] = result.sentiment;\n  });\n  return sentimentMap;\n};\n\n/**\n * Mock function for sentiment analysis (used as fallback)\n */\nconst mockAnalyzeSentiment = text => {\n  const lowerText = text.toLowerCase();\n\n  // Simple keyword-based sentiment analysis\n  const positiveWords = ['love', 'great', 'good', 'amazing', 'excellent', 'awesome', 'fantastic', 'helpful', 'best', 'easy', 'like', 'impressed'];\n  const negativeWords = ['bad', 'terrible', 'awful', 'poor', 'difficult', 'annoying', 'frustrating', 'hate', 'slow', 'worst', 'broken', 'issue', 'problem', 'error', 'bug'];\n  let positiveCount = 0;\n  let negativeCount = 0;\n  positiveWords.forEach(word => {\n    if (lowerText.includes(word)) positiveCount++;\n  });\n  negativeWords.forEach(word => {\n    if (lowerText.includes(word)) negativeCount++;\n  });\n  if (positiveCount > negativeCount) {\n    return {\n      sentiment: 'Positive',\n      confidence: 0.7\n    };\n  } else if (negativeCount > positiveCount) {\n    return {\n      sentiment: 'Negative',\n      confidence: 0.7\n    };\n  } else {\n    return {\n      sentiment: 'Neutral',\n      confidence: 0.5\n    };\n  }\n};","map":{"version":3,"names":["axios","OPENAI_API_URL","API_KEY","process","env","REACT_APP_OPENAI_API_KEY","classifyFeedback","feedbackText","console","warn","mockClassifyFeedback","response","post","model","messages","role","content","temperature","max_tokens","headers","assistantMessage","data","choices","message","match","JSON","parse","Error","error","batchClassifyFeedback","feedbackItems","fallbackBatchClassify","feedbackTexts","map","item","index","text","join","results","themeMap","forEach","result","feedbackItem","feedbackIndex","id","theme","generateFeatureIdeas","relatedFeedback","mockGenerateFeatureIdeas","feedbackContext","length","slice","analyzeSentiment","log","fetch","method","body","stringify","instructions","ok","status","json","sentiment","includes","batchAnalyzeSentiment","fallbackBatchSentiment","sentimentMap","lowerText","toLowerCase","name","description","priority","mockAnalyzeSentiment","positiveWords","negativeWords","positiveCount","negativeCount","word","confidence"],"sources":["/Users/faisalshariff/Feedback Force/src/services/openaiService.js"],"sourcesContent":["import axios from 'axios';\n\nconst OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';\n\n// You'll need to set this in your environment variables\nconst API_KEY = process.env.REACT_APP_OPENAI_API_KEY;\n\n/**\n * Classify feedback text into themes using OpenAI\n * @param {string} feedbackText - The feedback text to classify\n * @returns {Promise<Object>} - An object containing the theme and confidence\n */\nexport const classifyFeedback = async (feedbackText) => {\n  try {\n    // Check if the API key is available\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback classification.');\n      return mockClassifyFeedback(feedbackText);\n    }\n\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-3.5-turbo',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are an assistant that categorizes user feedback into a single theme. Choose the most appropriate theme from: Performance, Usability, Design, Functionality, Data Visualization, Mobile Experience, Error Handling, or create a new appropriate theme if none of these fit well.'\n          },\n          {\n            role: 'user',\n            content: `Categorize this feedback into a single theme: \"${feedbackText}\". Respond with a JSON object with the format {\"theme\": \"ThemeName\", \"confidence\": 0.X} where confidence is a number between 0 and 1.`\n          }\n        ],\n        temperature: 0.3,\n        max_tokens: 100\n      },\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${API_KEY}`\n        }\n      }\n    );\n\n    // Parse the response to extract the theme\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\{.*\\}/s);\n    \n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse theme from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error classifying feedback with OpenAI:', error);\n    // Fall back to keyword-based classification\n    return mockClassifyFeedback(feedbackText);\n  }\n};\n\n/**\n * Process a batch of feedback texts to extract themes using OpenAI\n * @param {Array} feedbackItems - Array of feedback objects\n * @returns {Promise<Object>} - Mapping of feedback IDs to themes\n */\nexport const batchClassifyFeedback = async (feedbackItems) => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback classification.');\n      return fallbackBatchClassify(feedbackItems);\n    }\n\n    // Prepare the batch prompt\n    const feedbackTexts = feedbackItems.map((item, index) => \n      `Feedback ${index + 1}: \"${item.text}\"`\n    ).join('\\n\\n');\n\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-3.5-turbo-16k',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are an assistant that categorizes multiple pieces of user feedback into themes. Choose appropriate themes from: Performance, Usability, Design, Functionality, Data Visualization, Mobile Experience, Error Handling, or create new themes if needed.'\n          },\n          {\n            role: 'user',\n            content: `Categorize each of these feedback items into a single theme:\\n\\n${feedbackTexts}\\n\\nRespond with a JSON array with the format [{\"feedbackIndex\": 1, \"theme\": \"ThemeName\"}, {\"feedbackIndex\": 2, \"theme\": \"ThemeName\"}, ...] for each feedback item.`\n          }\n        ],\n        temperature: 0.3,\n        max_tokens: 2000\n      },\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${API_KEY}`\n        }\n      }\n    );\n\n    // Parse the response to extract the themes\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\[\\s*\\{.*\\}\\s*\\]/s);\n    \n    if (match) {\n      const results = JSON.parse(match[0]);\n      \n      // Create a mapping of feedback ID to theme\n      const themeMap = {};\n      results.forEach(result => {\n        const feedbackItem = feedbackItems[result.feedbackIndex - 1];\n        if (feedbackItem) {\n          themeMap[feedbackItem.id] = result.theme;\n        }\n      });\n      \n      return themeMap;\n    } else {\n      throw new Error('Could not parse themes from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error batch classifying feedback with OpenAI:', error);\n    // Fall back to individual keyword-based classification\n    return fallbackBatchClassify(feedbackItems);\n  }\n};\n\n/**\n * Generate feature ideas based on feedback themes\n * @param {string} theme - The theme to generate feature ideas for\n * @param {Array} relatedFeedback - Array of related feedback texts\n * @returns {Promise<Array>} - Array of feature ideas\n */\nexport const generateFeatureIdeas = async (theme, relatedFeedback = []) => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback feature generation.');\n      return mockGenerateFeatureIdeas(theme);\n    }\n\n    // Prepare the context with related feedback\n    let feedbackContext = '';\n    if (relatedFeedback && relatedFeedback.length > 0) {\n      feedbackContext = `Here are some examples of user feedback related to this theme:\\n\\n${relatedFeedback.slice(0, 5).join('\\n\\n')}`;\n    }\n\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-3.5-turbo',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are a product manager who generates practical feature ideas based on user feedback themes.'\n          },\n          {\n            role: 'user',\n            content: `Generate 2-3 feature ideas to address the \"${theme}\" theme in our application. ${feedbackContext}\\n\\nRespond with a JSON array of features with the format [{\"name\": \"Feature Name\", \"description\": \"Brief description\", \"priority\": \"High/Medium/Low\"}]`\n          }\n        ],\n        temperature: 0.7,\n        max_tokens: 500\n      },\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${API_KEY}`\n        }\n      }\n    );\n\n    // Parse the response to extract the feature ideas\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\[\\s*\\{.*\\}\\s*\\]/s);\n    \n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse feature ideas from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error generating feature ideas with OpenAI:', error);\n    // Fall back to mock feature generation\n    return mockGenerateFeatureIdeas(theme);\n  }\n};\n\n/**\n * Analyze sentiment of feedback text using OpenAI\n * @param {string} text - The feedback text to analyze\n * @returns {Promise<Object>} - An object containing sentiment and confidence\n */\nexport const analyzeSentiment = async (text) => {\n  try {\n    // Log the text being analyzed for debugging\n    console.log(\"Analyzing sentiment for:\", text);\n    \n    // Create a more specific prompt for the OpenAI API\n    const response = await fetch('/api/analyze-sentiment', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ \n        text,\n        // Add specific instructions to ensure accurate classification\n        instructions: `\n          Analyze the sentiment of this user feedback for a software application.\n          \n          Guidelines:\n          - Classify as \"Negative\" if the feedback expresses any problems, complaints, frustrations, \n            or suggestions for fixing issues, even if politely phrased\n          - Classify as \"Positive\" only if the feedback is clearly expressing satisfaction or praise\n          - Use \"Neutral\" only for purely factual statements without emotional content\n          \n          Important: Any mention of bugs, crashes, difficulties, confusion, or feature requests \n          should be classified as \"Negative\" as they indicate user pain points.\n          \n          Return only \"Positive\", \"Negative\", or \"Neutral\".\n        `\n      }),\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Failed to analyze sentiment: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    console.log(\"Sentiment analysis result:\", data);\n    \n    // Ensure we have a valid sentiment value\n    if (!data.sentiment || !['Positive', 'Negative', 'Neutral'].includes(data.sentiment)) {\n      console.warn(\"Invalid sentiment received:\", data.sentiment);\n      // Default to a more cautious classification if the API returns something unexpected\n      return { sentiment: \"Negative\" };\n    }\n    \n    return { sentiment: data.sentiment };\n  } catch (error) {\n    console.error('Error analyzing sentiment:', error);\n    // In case of error, default to Negative to be cautious\n    return { sentiment: \"Negative\" };\n  }\n};\n\n/**\n * Batch analyze sentiment for multiple feedback texts\n * @param {Array} feedbackItems - Array of feedback objects\n * @returns {Promise<Object>} - Mapping of feedback IDs to sentiment\n */\nexport const batchAnalyzeSentiment = async (feedbackItems) => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback sentiment analysis.');\n      return fallbackBatchSentiment(feedbackItems);\n    }\n\n    // Prepare the batch prompt\n    const feedbackTexts = feedbackItems.map((item, index) => \n      `Feedback ${index + 1}: \"${item.text}\"`\n    ).join('\\n\\n');\n\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-3.5-turbo-16k',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are an assistant that analyzes the sentiment of multiple pieces of user feedback. Classify each as Positive, Negative, or Neutral.'\n          },\n          {\n            role: 'user',\n            content: `Analyze the sentiment of each of these feedback items:\\n\\n${feedbackTexts}\\n\\nRespond with a JSON array with the format [{\"feedbackIndex\": 1, \"sentiment\": \"Positive/Negative/Neutral\"}, {\"feedbackIndex\": 2, \"sentiment\": \"Positive/Negative/Neutral\"}, ...] for each feedback item.`\n          }\n        ],\n        temperature: 0.3,\n        max_tokens: 2000\n      },\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${API_KEY}`\n        }\n      }\n    );\n\n    // Parse the response to extract the sentiments\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\[\\s*\\{.*\\}\\s*\\]/s);\n    \n    if (match) {\n      const results = JSON.parse(match[0]);\n      \n      // Create a mapping of feedback ID to sentiment\n      const sentimentMap = {};\n      results.forEach(result => {\n        const feedbackItem = feedbackItems[result.feedbackIndex - 1];\n        if (feedbackItem) {\n          sentimentMap[feedbackItem.id] = result.sentiment;\n        }\n      });\n      \n      return sentimentMap;\n    } else {\n      throw new Error('Could not parse sentiments from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error batch analyzing sentiment with OpenAI:', error);\n    return fallbackBatchSentiment(feedbackItems);\n  }\n};\n\n/**\n * Fallback function for batch classification\n * @param {Array} feedbackItems - Array of feedback objects\n * @returns {Object} - Mapping of feedback IDs to themes\n */\nconst fallbackBatchClassify = (feedbackItems) => {\n  const themeMap = {};\n  feedbackItems.forEach(item => {\n    const result = mockClassifyFeedback(item.text);\n    themeMap[item.id] = result.theme;\n  });\n  return themeMap;\n};\n\n/**\n * Mock function for keyword-based theme classification (used as fallback)\n * @param {string} text - The feedback text to classify\n * @returns {Object} - An object containing the theme\n */\nconst mockClassifyFeedback = (text) => {\n  const lowerText = text.toLowerCase();\n  \n  if (lowerText.includes('crash') || lowerText.includes('error') || lowerText.includes('bug')) {\n    return { theme: 'Error Handling' };\n  } else if (lowerText.includes('slow') || lowerText.includes('performance') || lowerText.includes('timeout') || lowerText.includes('load')) {\n    return { theme: 'Performance' };\n  } else if (lowerText.includes('mobile') || lowerText.includes('app') || lowerText.includes('phone')) {\n    return { theme: 'Mobile Experience' };\n  } else if (lowerText.includes('ui') || lowerText.includes('interface') || lowerText.includes('design') || \n            lowerText.includes('layout') || lowerText.includes('look')) {\n    return { theme: 'Design' };\n  } else if (lowerText.includes('report') || lowerText.includes('dashboard')) {\n    return { theme: 'Data Visualization' };\n  } else if (lowerText.includes('export') || lowerText.includes('excel') || lowerText.includes('pdf')) {\n    return { theme: 'Data Export' };\n  } else if (lowerText.includes('search') || lowerText.includes('filter') || lowerText.includes('find')) {\n    return { theme: 'Navigation' };\n  } else if (lowerText.includes('easy') || lowerText.includes('difficult') || lowerText.includes('confusing') || \n            lowerText.includes('intuitive') || lowerText.includes('user-friendly')) {\n    return { theme: 'Usability' };\n  } else if (lowerText.includes('feature') || lowerText.includes('function') || lowerText.includes('capability')) {\n    return { theme: 'Functionality' };\n  }\n  \n  return { theme: 'General Feedback' };\n};\n\n/**\n * Mock function for feature idea generation (used as fallback)\n * @param {string} theme - The theme to generate feature ideas for\n * @returns {Array} - Array of feature ideas\n */\nconst mockGenerateFeatureIdeas = (theme) => {\n  switch (theme) {\n    case 'Error Handling':\n      return [\n        { \n          name: 'Intelligent Error Recovery', \n          description: 'Automatically recover from common errors without user intervention',\n          priority: 'High'\n        },\n        {\n          name: 'User-Friendly Error Messages',\n          description: 'Replace technical error messages with clear action items for users',\n          priority: 'Medium'\n        }\n      ];\n    case 'Performance':\n      return [\n        { \n          name: 'Optimized Data Loading', \n          description: 'Implement progressive loading and caching for faster dashboard performance',\n          priority: 'High'\n        },\n        {\n          name: 'Background Processing',\n          description: 'Move heavy calculations to background threads to keep UI responsive',\n          priority: 'Medium'\n        }\n      ];\n    case 'Design':\n      return [\n        { \n          name: 'Redesigned Interface', \n          description: 'Streamline UI with modern design principles and improved visual hierarchy',\n          priority: 'Medium'\n        },\n        {\n          name: 'Customizable Themes',\n          description: 'Allow users to personalize the interface with color themes and layouts',\n          priority: 'Low'\n        }\n      ];\n    default:\n      return [\n        { \n          name: `${theme} Improvements`, \n          description: `Address user feedback related to ${theme.toLowerCase()}`,\n          priority: 'Medium'\n        },\n        {\n          name: 'User Experience Enhancement',\n          description: 'General improvements based on feedback analysis',\n          priority: 'Medium'\n        }\n      ];\n  }\n};\n\n/**\n * Fallback function for batch sentiment analysis\n */\nconst fallbackBatchSentiment = (feedbackItems) => {\n  const sentimentMap = {};\n  feedbackItems.forEach(item => {\n    const result = mockAnalyzeSentiment(item.text);\n    sentimentMap[item.id] = result.sentiment;\n  });\n  return sentimentMap;\n};\n\n/**\n * Mock function for sentiment analysis (used as fallback)\n */\nconst mockAnalyzeSentiment = (text) => {\n  const lowerText = text.toLowerCase();\n  \n  // Simple keyword-based sentiment analysis\n  const positiveWords = ['love', 'great', 'good', 'amazing', 'excellent', 'awesome', 'fantastic', 'helpful', 'best', 'easy', 'like', 'impressed'];\n  const negativeWords = ['bad', 'terrible', 'awful', 'poor', 'difficult', 'annoying', 'frustrating', 'hate', 'slow', 'worst', 'broken', 'issue', 'problem', 'error', 'bug'];\n  \n  let positiveCount = 0;\n  let negativeCount = 0;\n  \n  positiveWords.forEach(word => {\n    if (lowerText.includes(word)) positiveCount++;\n  });\n  \n  negativeWords.forEach(word => {\n    if (lowerText.includes(word)) negativeCount++;\n  });\n  \n  if (positiveCount > negativeCount) {\n    return { sentiment: 'Positive', confidence: 0.7 };\n  } else if (negativeCount > positiveCount) {\n    return { sentiment: 'Negative', confidence: 0.7 };\n  } else {\n    return { sentiment: 'Neutral', confidence: 0.5 };\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}