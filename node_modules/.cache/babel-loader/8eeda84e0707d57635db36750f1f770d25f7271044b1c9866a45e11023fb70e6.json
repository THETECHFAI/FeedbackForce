{"ast":null,"code":"import axios from 'axios';\nconst OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';\n\n// You'll need to set this in your environment variables\nconst API_KEY = process.env.REACT_APP_OPENAI_API_KEY;\n\n/**\n * Classify feedback text into themes using OpenAI\n * @param {string} feedbackText - The feedback text to classify\n * @returns {Promise<Object>} - An object containing the theme and confidence\n */\nexport const classifyFeedback = async feedbackText => {\n  try {\n    // Check if the API key is available\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback classification.');\n      return mockClassifyFeedback(feedbackText);\n    }\n    const response = await axios.post('https://api.openai.com/v1/chat/completions', {\n      model: 'gpt-3.5-turbo',\n      messages: [{\n        role: 'system',\n        content: 'You are an assistant that categorizes user feedback into a single theme. Choose the most appropriate theme from: Performance, Usability, Design, Functionality, Data Visualization, Mobile Experience, Error Handling, or create a new appropriate theme if none of these fit well.'\n      }, {\n        role: 'user',\n        content: `Categorize this feedback into a single theme: \"${feedbackText}\". Respond with a JSON object with the format {\"theme\": \"ThemeName\", \"confidence\": 0.X} where confidence is a number between 0 and 1.`\n      }],\n      temperature: 0.3,\n      max_tokens: 100\n    }, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`\n      }\n    });\n\n    // Parse the response to extract the theme\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\{.*\\}/s);\n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse theme from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error classifying feedback with OpenAI:', error);\n    // Fall back to keyword-based classification\n    return mockClassifyFeedback(feedbackText);\n  }\n};\n\n/**\n * Process a batch of feedback texts to extract themes using OpenAI\n * @param {Array} feedbackItems - Array of feedback objects\n * @returns {Promise<Object>} - Mapping of feedback IDs to themes\n */\nexport const batchClassifyFeedback = async feedbackItems => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback classification.');\n      return fallbackBatchClassify(feedbackItems);\n    }\n\n    // Prepare the batch prompt\n    const feedbackTexts = feedbackItems.map((item, index) => `Feedback ${index + 1}: \"${item.text}\"`).join('\\n\\n');\n    const response = await axios.post('https://api.openai.com/v1/chat/completions', {\n      model: 'gpt-3.5-turbo-16k',\n      messages: [{\n        role: 'system',\n        content: 'You are an assistant that categorizes multiple pieces of user feedback into themes. Choose appropriate themes from: Performance, Usability, Design, Functionality, Data Visualization, Mobile Experience, Error Handling, or create new themes if needed.'\n      }, {\n        role: 'user',\n        content: `Categorize each of these feedback items into a single theme:\\n\\n${feedbackTexts}\\n\\nRespond with a JSON array with the format [{\"feedbackIndex\": 1, \"theme\": \"ThemeName\"}, {\"feedbackIndex\": 2, \"theme\": \"ThemeName\"}, ...] for each feedback item.`\n      }],\n      temperature: 0.3,\n      max_tokens: 2000\n    }, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`\n      }\n    });\n\n    // Parse the response to extract the themes\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\[\\s*\\{.*\\}\\s*\\]/s);\n    if (match) {\n      const results = JSON.parse(match[0]);\n\n      // Create a mapping of feedback ID to theme\n      const themeMap = {};\n      results.forEach(result => {\n        const feedbackItem = feedbackItems[result.feedbackIndex - 1];\n        if (feedbackItem) {\n          themeMap[feedbackItem.id] = result.theme;\n        }\n      });\n      return themeMap;\n    } else {\n      throw new Error('Could not parse themes from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error batch classifying feedback with OpenAI:', error);\n    // Fall back to individual keyword-based classification\n    return fallbackBatchClassify(feedbackItems);\n  }\n};\n\n/**\n * Generate feature ideas based on feedback themes\n * @param {string} theme - The theme to generate feature ideas for\n * @param {Array} relatedFeedback - Array of related feedback texts\n * @returns {Promise<Array>} - Array of feature ideas\n */\nexport const generateFeatureIdeas = async (theme, relatedFeedback = []) => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback feature generation.');\n      return mockGenerateFeatureIdeas(theme);\n    }\n\n    // Prepare the context with related feedback\n    let feedbackContext = '';\n    if (relatedFeedback && relatedFeedback.length > 0) {\n      feedbackContext = `Here are some examples of user feedback related to this theme:\\n\\n${relatedFeedback.slice(0, 5).join('\\n\\n')}`;\n    }\n    const response = await axios.post('https://api.openai.com/v1/chat/completions', {\n      model: 'gpt-3.5-turbo',\n      messages: [{\n        role: 'system',\n        content: 'You are a product manager who generates practical feature ideas based on user feedback themes.'\n      }, {\n        role: 'user',\n        content: `Generate 2-3 feature ideas to address the \"${theme}\" theme in our application. ${feedbackContext}\\n\\nRespond with a JSON array of features with the format [{\"name\": \"Feature Name\", \"description\": \"Brief description\", \"priority\": \"High/Medium/Low\"}]`\n      }],\n      temperature: 0.7,\n      max_tokens: 500\n    }, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`\n      }\n    });\n\n    // Parse the response to extract the feature ideas\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\[\\s*\\{.*\\}\\s*\\]/s);\n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse feature ideas from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error generating feature ideas with OpenAI:', error);\n    // Fall back to mock feature generation\n    return mockGenerateFeatureIdeas(theme);\n  }\n};\n\n/**\n * Analyze sentiment of feedback text using OpenAI\n * @param {string} feedbackText - The feedback text to analyze\n * @returns {Promise<Object>} - An object containing sentiment and confidence\n */\nexport const analyzeSentiment = async feedbackText => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback sentiment analysis.');\n      return mockAnalyzeSentiment(feedbackText);\n    }\n    const response = await axios.post('https://api.openai.com/v1/chat/completions', {\n      model: 'gpt-3.5-turbo',\n      messages: [{\n        role: 'system',\n        content: 'You are an assistant that analyzes the sentiment of user feedback. Classify the sentiment as Positive, Negative, or Neutral.'\n      }, {\n        role: 'user',\n        content: `Analyze the sentiment of this feedback: \"${feedbackText}\". Respond with a JSON object with the format {\"sentiment\": \"Positive/Negative/Neutral\", \"confidence\": 0.X} where confidence is a number between 0 and 1.`\n      }],\n      temperature: 0.3,\n      max_tokens: 100\n    }, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`\n      }\n    });\n\n    // Parse the response to extract the sentiment\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\{.*\\}/s);\n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse sentiment from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error analyzing sentiment with OpenAI:', error);\n    return mockAnalyzeSentiment(feedbackText);\n  }\n};\n\n/**\n * Batch analyze sentiment for multiple feedback texts\n * @param {Array} feedbackItems - Array of feedback objects\n * @returns {Promise<Object>} - Mapping of feedback IDs to sentiment\n */\nexport const batchAnalyzeSentiment = async feedbackItems => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback sentiment analysis.');\n      return fallbackBatchSentiment(feedbackItems);\n    }\n\n    // Prepare the batch prompt\n    const feedbackTexts = feedbackItems.map((item, index) => `Feedback ${index + 1}: \"${item.text}\"`).join('\\n\\n');\n    const response = await axios.post('https://api.openai.com/v1/chat/completions', {\n      model: 'gpt-3.5-turbo-16k',\n      messages: [{\n        role: 'system',\n        content: 'You are an assistant that analyzes the sentiment of multiple pieces of user feedback. Classify each as Positive, Negative, or Neutral.'\n      }, {\n        role: 'user',\n        content: `Analyze the sentiment of each of these feedback items:\\n\\n${feedbackTexts}\\n\\nRespond with a JSON array with the format [{\"feedbackIndex\": 1, \"sentiment\": \"Positive/Negative/Neutral\"}, {\"feedbackIndex\": 2, \"sentiment\": \"Positive/Negative/Neutral\"}, ...] for each feedback item.`\n      }],\n      temperature: 0.3,\n      max_tokens: 2000\n    }, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`\n      }\n    });\n\n    // Parse the response to extract the sentiments\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\[\\s*\\{.*\\}\\s*\\]/s);\n    if (match) {\n      const results = JSON.parse(match[0]);\n\n      // Create a mapping of feedback ID to sentiment\n      const sentimentMap = {};\n      results.forEach(result => {\n        const feedbackItem = feedbackItems[result.feedbackIndex - 1];\n        if (feedbackItem) {\n          sentimentMap[feedbackItem.id] = result.sentiment;\n        }\n      });\n      return sentimentMap;\n    } else {\n      throw new Error('Could not parse sentiments from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error batch analyzing sentiment with OpenAI:', error);\n    return fallbackBatchSentiment(feedbackItems);\n  }\n};\n\n/**\n * Fallback function for batch classification\n * @param {Array} feedbackItems - Array of feedback objects\n * @returns {Object} - Mapping of feedback IDs to themes\n */\nconst fallbackBatchClassify = feedbackItems => {\n  const themeMap = {};\n  feedbackItems.forEach(item => {\n    const result = mockClassifyFeedback(item.text);\n    themeMap[item.id] = result.theme;\n  });\n  return themeMap;\n};\n\n/**\n * Mock function for keyword-based theme classification (used as fallback)\n * @param {string} text - The feedback text to classify\n * @returns {Object} - An object containing the theme\n */\nconst mockClassifyFeedback = text => {\n  const lowerText = text.toLowerCase();\n  if (lowerText.includes('crash') || lowerText.includes('error') || lowerText.includes('bug')) {\n    return {\n      theme: 'Error Handling'\n    };\n  } else if (lowerText.includes('slow') || lowerText.includes('performance') || lowerText.includes('timeout') || lowerText.includes('load')) {\n    return {\n      theme: 'Performance'\n    };\n  } else if (lowerText.includes('mobile') || lowerText.includes('app') || lowerText.includes('phone')) {\n    return {\n      theme: 'Mobile Experience'\n    };\n  } else if (lowerText.includes('ui') || lowerText.includes('interface') || lowerText.includes('design') || lowerText.includes('layout') || lowerText.includes('look')) {\n    return {\n      theme: 'Design'\n    };\n  } else if (lowerText.includes('report') || lowerText.includes('dashboard')) {\n    return {\n      theme: 'Data Visualization'\n    };\n  } else if (lowerText.includes('export') || lowerText.includes('excel') || lowerText.includes('pdf')) {\n    return {\n      theme: 'Data Export'\n    };\n  } else if (lowerText.includes('search') || lowerText.includes('filter') || lowerText.includes('find')) {\n    return {\n      theme: 'Navigation'\n    };\n  } else if (lowerText.includes('easy') || lowerText.includes('difficult') || lowerText.includes('confusing') || lowerText.includes('intuitive') || lowerText.includes('user-friendly')) {\n    return {\n      theme: 'Usability'\n    };\n  } else if (lowerText.includes('feature') || lowerText.includes('function') || lowerText.includes('capability')) {\n    return {\n      theme: 'Functionality'\n    };\n  }\n  return {\n    theme: 'General Feedback'\n  };\n};\n\n/**\n * Mock function for feature idea generation (used as fallback)\n * @param {string} theme - The theme to generate feature ideas for\n * @returns {Array} - Array of feature ideas\n */\nconst mockGenerateFeatureIdeas = theme => {\n  switch (theme) {\n    case 'Error Handling':\n      return [{\n        name: 'Intelligent Error Recovery',\n        description: 'Automatically recover from common errors without user intervention',\n        priority: 'High'\n      }, {\n        name: 'User-Friendly Error Messages',\n        description: 'Replace technical error messages with clear action items for users',\n        priority: 'Medium'\n      }];\n    case 'Performance':\n      return [{\n        name: 'Optimized Data Loading',\n        description: 'Implement progressive loading and caching for faster dashboard performance',\n        priority: 'High'\n      }, {\n        name: 'Background Processing',\n        description: 'Move heavy calculations to background threads to keep UI responsive',\n        priority: 'Medium'\n      }];\n    case 'Design':\n      return [{\n        name: 'Redesigned Interface',\n        description: 'Streamline UI with modern design principles and improved visual hierarchy',\n        priority: 'Medium'\n      }, {\n        name: 'Customizable Themes',\n        description: 'Allow users to personalize the interface with color themes and layouts',\n        priority: 'Low'\n      }];\n    default:\n      return [{\n        name: `${theme} Improvements`,\n        description: `Address user feedback related to ${theme.toLowerCase()}`,\n        priority: 'Medium'\n      }, {\n        name: 'User Experience Enhancement',\n        description: 'General improvements based on feedback analysis',\n        priority: 'Medium'\n      }];\n  }\n};\n\n/**\n * Fallback function for batch sentiment analysis\n */\nconst fallbackBatchSentiment = feedbackItems => {\n  const sentimentMap = {};\n  feedbackItems.forEach(item => {\n    const result = mockAnalyzeSentiment(item.text);\n    sentimentMap[item.id] = result.sentiment;\n  });\n  return sentimentMap;\n};\n\n/**\n * Mock function for sentiment analysis (used as fallback)\n */\nconst mockAnalyzeSentiment = text => {\n  const lowerText = text.toLowerCase();\n\n  // Simple keyword-based sentiment analysis\n  const positiveWords = ['love', 'great', 'good', 'amazing', 'excellent', 'awesome', 'fantastic', 'helpful', 'best', 'easy', 'like', 'impressed'];\n  const negativeWords = ['bad', 'terrible', 'awful', 'poor', 'difficult', 'annoying', 'frustrating', 'hate', 'slow', 'worst', 'broken', 'issue', 'problem', 'error', 'bug'];\n  let positiveCount = 0;\n  let negativeCount = 0;\n  positiveWords.forEach(word => {\n    if (lowerText.includes(word)) positiveCount++;\n  });\n  negativeWords.forEach(word => {\n    if (lowerText.includes(word)) negativeCount++;\n  });\n  if (positiveCount > negativeCount) {\n    return {\n      sentiment: 'Positive',\n      confidence: 0.7\n    };\n  } else if (negativeCount > positiveCount) {\n    return {\n      sentiment: 'Negative',\n      confidence: 0.7\n    };\n  } else {\n    return {\n      sentiment: 'Neutral',\n      confidence: 0.5\n    };\n  }\n};\n\n/**\n * Generate insights for a specific persona\n * @param {Object} persona - The persona node data\n * @param {Array} relatedFeedback - Feedback from this persona\n * @param {Array} connectedThemes - Themes this persona is connected to\n * @returns {Promise<Object>} AI insights about this persona\n */\nexport const analyzePersona = async (persona, relatedFeedback, connectedThemes) => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback persona analysis.');\n      return mockPersonaAnalysis(persona, relatedFeedback, connectedThemes);\n    }\n\n    // Extract feedback text for context\n    const feedbackTexts = relatedFeedback.map(f => f.text).join('\\n• ');\n    const themeNames = connectedThemes.map(t => t.name).join(', ');\n    const response = await axios.post('https://api.openai.com/v1/chat/completions', {\n      model: 'gpt-3.5-turbo',\n      messages: [{\n        role: 'system',\n        content: 'You are a user research analyst who provides concise, actionable insights about user personas based on their feedback.'\n      }, {\n        role: 'user',\n        content: `Analyze this \"${persona.name}\" user persona and their feedback:\\n\\nRole: ${persona.name}\\nTotal Feedback: ${persona.feedbackCount}\\nMain Themes: ${themeNames}\\n\\nSample Feedback:\\n• ${feedbackTexts}\\n\\nProvide insights in JSON format with these fields:\\n1. \"patterns\" - Key patterns in their feedback (1-2 sentences)\\n2. \"painPoints\" - Their main pain points (1-2 sentences)\\n3. \"suggestions\" - 2-3 specific improvements for this user type (short bullet points)\\n4. \"priority\" - How to prioritize addressing their needs (High/Medium/Low with brief justification)`\n      }],\n      temperature: 0.5,\n      max_tokens: 600\n    }, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`\n      }\n    });\n\n    // Parse response\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\{.*\\}/s);\n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse persona analysis from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error analyzing persona with OpenAI:', error);\n    return mockPersonaAnalysis(persona, relatedFeedback, connectedThemes);\n  }\n};\n\n/**\n * Generate insights for a specific theme\n * @param {Object} theme - The theme node data\n * @param {Array} relatedFeedback - Feedback related to this theme\n * @param {Array} connectedPersonas - Personas connected to this theme\n * @returns {Promise<Object>} AI insights about this theme\n */\nexport const analyzeTheme = async (theme, relatedFeedback, connectedPersonas) => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback theme analysis.');\n      return mockThemeAnalysis(theme, relatedFeedback, connectedPersonas);\n    }\n\n    // Calculate sentiment distribution for context\n    const sentimentCounts = {\n      Positive: 0,\n      Negative: 0,\n      Neutral: 0\n    };\n    relatedFeedback.forEach(f => {\n      sentimentCounts[f.sentiment || 'Neutral']++;\n    });\n\n    // Extract sample feedback text\n    const sampleFeedback = relatedFeedback.slice(0, 5).map(f => `• ${f.text} (Sentiment: ${f.sentiment || 'Neutral'})`).join('\\n');\n    const personaNames = connectedPersonas.map(p => p.name).join(', ');\n    const response = await axios.post('https://api.openai.com/v1/chat/completions', {\n      model: 'gpt-3.5-turbo',\n      messages: [{\n        role: 'system',\n        content: 'You are a product analyst who provides concise, actionable insights about product themes based on user feedback.'\n      }, {\n        role: 'user',\n        content: `Analyze the \"${theme.name}\" theme based on this feedback:\\n\\nFeedback Count: ${theme.feedbackCount}\\nSentiment: ${sentimentCounts.Positive} positive, ${sentimentCounts.Negative} negative, ${sentimentCounts.Neutral} neutral\\nUser Types: ${personaNames}\\n\\nSample Feedback:\\n${sampleFeedback}\\n\\nProvide insights in JSON format with these fields:\\n1. \"trends\" - Key trends in the feedback about this theme (1-2 sentences)\\n2. \"priority\" - How urgent is addressing this theme (High/Medium/Low with brief justification)\\n3. \"solutions\" - 2-3 specific potential solutions (short bullet points)\\n4. \"impact\" - The potential impact of addressing this theme (1-2 sentences)`\n      }],\n      temperature: 0.5,\n      max_tokens: 600\n    }, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`\n      }\n    });\n\n    // Parse response\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\{.*\\}/s);\n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse theme analysis from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error analyzing theme with OpenAI:', error);\n    return mockThemeAnalysis(theme, relatedFeedback, connectedPersonas);\n  }\n};\n\n/**\n * Generate insights for a specific feedback item\n * @param {Object} feedback - The feedback node data\n * @param {Array} similarFeedback - Similar feedback items\n * @returns {Promise<Object>} AI insights about this feedback\n */\nexport const analyzeFeedback = async (feedback, similarFeedback = []) => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback feedback analysis.');\n      return mockFeedbackAnalysis(feedback);\n    }\n\n    // Extract similar feedback for context\n    const similarFeedbackText = similarFeedback.slice(0, 3).map(f => `• ${f.text}`).join('\\n');\n    const response = await axios.post('https://api.openai.com/v1/chat/completions', {\n      model: 'gpt-3.5-turbo',\n      messages: [{\n        role: 'system',\n        content: 'You are a customer feedback analyst who provides concise, actionable insights about individual pieces of feedback.'\n      }, {\n        role: 'user',\n        content: `Analyze this feedback item:\\n\\nFeedback: \"${feedback.title || feedback.text}\"\\nUser Role: ${feedback.user_role || 'Unknown'}\\nTheme: ${feedback.theme || 'Unclassified'}\\n${similarFeedbackText ? `\\nSimilar Feedback:\\n${similarFeedbackText}` : ''}\\n\\nProvide insights in JSON format with these fields:\\n1. \"sentiment\" - A precise sentiment analysis (Very Positive/Positive/Neutral/Negative/Very Negative)\\n2. \"keyPoints\" - The main points of this feedback (1-2 sentences)\\n3. \"actionItems\" - 1-3 specific actions to address this feedback (short bullet points)\\n4. \"broader\" - How this feedback relates to broader product/service issues (1 sentence)`\n      }],\n      temperature: 0.5,\n      max_tokens: 500\n    }, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`\n      }\n    });\n\n    // Parse response\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\{.*\\}/s);\n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse feedback analysis from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error analyzing feedback with OpenAI:', error);\n    return mockFeedbackAnalysis(feedback);\n  }\n};\n\n/**\n * Mock persona analysis for fallback\n */\nconst mockPersonaAnalysis = (persona, relatedFeedback, connectedThemes) => {\n  var _relatedFeedback$0$th;\n  return {\n    patterns: `${persona.name} users primarily focus on ${connectedThemes.length > 0 ? connectedThemes[0].name.toLowerCase() : 'functionality'} and efficiency in their feedback.`,\n    painPoints: `Main frustrations appear to be around ${relatedFeedback.length > 0 ? ((_relatedFeedback$0$th = relatedFeedback[0].theme) === null || _relatedFeedback$0$th === void 0 ? void 0 : _relatedFeedback$0$th.toLowerCase()) || 'usability' : 'usability'} issues and learning curve challenges.`,\n    suggestions: [\"Improve onboarding for this user type\", \"Streamline their most-used workflows\", `Enhance ${connectedThemes.length > 0 ? connectedThemes[0].name.toLowerCase() : 'core features'} specifically for ${persona.name} users`],\n    priority: persona.feedbackCount > 10 ? \"High - large user segment with significant pain points\" : \"Medium - address after critical issues\"\n  };\n};\n\n/**\n * Mock theme analysis for fallback\n */\nconst mockThemeAnalysis = (theme, relatedFeedback, connectedPersonas) => {\n  const isNegative = relatedFeedback.filter(f => f.sentiment === 'Negative').length > relatedFeedback.filter(f => f.sentiment === 'Positive').length;\n  return {\n    trends: `User feedback on ${theme.name} shows ${isNegative ? 'consistent frustration with current implementation' : 'mixed but generally positive reactions'}.`,\n    priority: isNegative ? \"High - significant user frustration in this area\" : \"Medium - improvements would enhance user experience\",\n    solutions: [`Redesign the ${theme.name.toLowerCase()} interface for clarity`, \"Add additional user guidance and tooltips\", \"Implement automated error recovery\"],\n    impact: `Addressing ${theme.name.toLowerCase()} issues would improve satisfaction for ${connectedPersonas.length} user types and potentially reduce support tickets.`\n  };\n};\n\n/**\n * Mock feedback analysis for fallback\n */\nconst mockFeedbackAnalysis = feedback => {\n  var _feedback$theme, _feedback$theme2, _feedback$theme3;\n  const isNegative = feedback.sentiment === 'Negative';\n  return {\n    sentiment: isNegative ? \"Negative\" : feedback.sentiment === 'Positive' ? \"Positive\" : \"Neutral\",\n    keyPoints: `This feedback ${isNegative ? 'highlights frustration with' : 'comments on'} ${((_feedback$theme = feedback.theme) === null || _feedback$theme === void 0 ? void 0 : _feedback$theme.toLowerCase()) || 'the product'}.`,\n    actionItems: [`Review the ${((_feedback$theme2 = feedback.theme) === null || _feedback$theme2 === void 0 ? void 0 : _feedback$theme2.toLowerCase()) || 'mentioned feature'} functionality`, \"Compare with similar user feedback\", isNegative ? \"Consider for next sprint prioritization\" : \"Note as positive feedback\"],\n    broader: `This feedback relates to broader ${((_feedback$theme3 = feedback.theme) === null || _feedback$theme3 === void 0 ? void 0 : _feedback$theme3.toLowerCase()) || 'user experience'} considerations in the product.`\n  };\n};","map":{"version":3,"names":["axios","OPENAI_API_URL","API_KEY","process","env","REACT_APP_OPENAI_API_KEY","classifyFeedback","feedbackText","console","warn","mockClassifyFeedback","response","post","model","messages","role","content","temperature","max_tokens","headers","assistantMessage","data","choices","message","match","JSON","parse","Error","error","batchClassifyFeedback","feedbackItems","fallbackBatchClassify","feedbackTexts","map","item","index","text","join","results","themeMap","forEach","result","feedbackItem","feedbackIndex","id","theme","generateFeatureIdeas","relatedFeedback","mockGenerateFeatureIdeas","feedbackContext","length","slice","analyzeSentiment","mockAnalyzeSentiment","batchAnalyzeSentiment","fallbackBatchSentiment","sentimentMap","sentiment","lowerText","toLowerCase","includes","name","description","priority","positiveWords","negativeWords","positiveCount","negativeCount","word","confidence","analyzePersona","persona","connectedThemes","mockPersonaAnalysis","f","themeNames","t","feedbackCount","analyzeTheme","connectedPersonas","mockThemeAnalysis","sentimentCounts","Positive","Negative","Neutral","sampleFeedback","personaNames","p","analyzeFeedback","feedback","similarFeedback","mockFeedbackAnalysis","similarFeedbackText","title","user_role","_relatedFeedback$0$th","patterns","painPoints","suggestions","isNegative","filter","trends","solutions","impact","_feedback$theme","_feedback$theme2","_feedback$theme3","keyPoints","actionItems","broader"],"sources":["/Users/faisalshariff/Feedback Force/src/services/openaiService.js"],"sourcesContent":["import axios from 'axios';\n\nconst OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';\n\n// You'll need to set this in your environment variables\nconst API_KEY = process.env.REACT_APP_OPENAI_API_KEY;\n\n/**\n * Classify feedback text into themes using OpenAI\n * @param {string} feedbackText - The feedback text to classify\n * @returns {Promise<Object>} - An object containing the theme and confidence\n */\nexport const classifyFeedback = async (feedbackText) => {\n  try {\n    // Check if the API key is available\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback classification.');\n      return mockClassifyFeedback(feedbackText);\n    }\n\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-3.5-turbo',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are an assistant that categorizes user feedback into a single theme. Choose the most appropriate theme from: Performance, Usability, Design, Functionality, Data Visualization, Mobile Experience, Error Handling, or create a new appropriate theme if none of these fit well.'\n          },\n          {\n            role: 'user',\n            content: `Categorize this feedback into a single theme: \"${feedbackText}\". Respond with a JSON object with the format {\"theme\": \"ThemeName\", \"confidence\": 0.X} where confidence is a number between 0 and 1.`\n          }\n        ],\n        temperature: 0.3,\n        max_tokens: 100\n      },\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${API_KEY}`\n        }\n      }\n    );\n\n    // Parse the response to extract the theme\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\{.*\\}/s);\n    \n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse theme from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error classifying feedback with OpenAI:', error);\n    // Fall back to keyword-based classification\n    return mockClassifyFeedback(feedbackText);\n  }\n};\n\n/**\n * Process a batch of feedback texts to extract themes using OpenAI\n * @param {Array} feedbackItems - Array of feedback objects\n * @returns {Promise<Object>} - Mapping of feedback IDs to themes\n */\nexport const batchClassifyFeedback = async (feedbackItems) => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback classification.');\n      return fallbackBatchClassify(feedbackItems);\n    }\n\n    // Prepare the batch prompt\n    const feedbackTexts = feedbackItems.map((item, index) => \n      `Feedback ${index + 1}: \"${item.text}\"`\n    ).join('\\n\\n');\n\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-3.5-turbo-16k',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are an assistant that categorizes multiple pieces of user feedback into themes. Choose appropriate themes from: Performance, Usability, Design, Functionality, Data Visualization, Mobile Experience, Error Handling, or create new themes if needed.'\n          },\n          {\n            role: 'user',\n            content: `Categorize each of these feedback items into a single theme:\\n\\n${feedbackTexts}\\n\\nRespond with a JSON array with the format [{\"feedbackIndex\": 1, \"theme\": \"ThemeName\"}, {\"feedbackIndex\": 2, \"theme\": \"ThemeName\"}, ...] for each feedback item.`\n          }\n        ],\n        temperature: 0.3,\n        max_tokens: 2000\n      },\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${API_KEY}`\n        }\n      }\n    );\n\n    // Parse the response to extract the themes\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\[\\s*\\{.*\\}\\s*\\]/s);\n    \n    if (match) {\n      const results = JSON.parse(match[0]);\n      \n      // Create a mapping of feedback ID to theme\n      const themeMap = {};\n      results.forEach(result => {\n        const feedbackItem = feedbackItems[result.feedbackIndex - 1];\n        if (feedbackItem) {\n          themeMap[feedbackItem.id] = result.theme;\n        }\n      });\n      \n      return themeMap;\n    } else {\n      throw new Error('Could not parse themes from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error batch classifying feedback with OpenAI:', error);\n    // Fall back to individual keyword-based classification\n    return fallbackBatchClassify(feedbackItems);\n  }\n};\n\n/**\n * Generate feature ideas based on feedback themes\n * @param {string} theme - The theme to generate feature ideas for\n * @param {Array} relatedFeedback - Array of related feedback texts\n * @returns {Promise<Array>} - Array of feature ideas\n */\nexport const generateFeatureIdeas = async (theme, relatedFeedback = []) => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback feature generation.');\n      return mockGenerateFeatureIdeas(theme);\n    }\n\n    // Prepare the context with related feedback\n    let feedbackContext = '';\n    if (relatedFeedback && relatedFeedback.length > 0) {\n      feedbackContext = `Here are some examples of user feedback related to this theme:\\n\\n${relatedFeedback.slice(0, 5).join('\\n\\n')}`;\n    }\n\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-3.5-turbo',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are a product manager who generates practical feature ideas based on user feedback themes.'\n          },\n          {\n            role: 'user',\n            content: `Generate 2-3 feature ideas to address the \"${theme}\" theme in our application. ${feedbackContext}\\n\\nRespond with a JSON array of features with the format [{\"name\": \"Feature Name\", \"description\": \"Brief description\", \"priority\": \"High/Medium/Low\"}]`\n          }\n        ],\n        temperature: 0.7,\n        max_tokens: 500\n      },\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${API_KEY}`\n        }\n      }\n    );\n\n    // Parse the response to extract the feature ideas\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\[\\s*\\{.*\\}\\s*\\]/s);\n    \n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse feature ideas from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error generating feature ideas with OpenAI:', error);\n    // Fall back to mock feature generation\n    return mockGenerateFeatureIdeas(theme);\n  }\n};\n\n/**\n * Analyze sentiment of feedback text using OpenAI\n * @param {string} feedbackText - The feedback text to analyze\n * @returns {Promise<Object>} - An object containing sentiment and confidence\n */\nexport const analyzeSentiment = async (feedbackText) => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback sentiment analysis.');\n      return mockAnalyzeSentiment(feedbackText);\n    }\n\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-3.5-turbo',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are an assistant that analyzes the sentiment of user feedback. Classify the sentiment as Positive, Negative, or Neutral.'\n          },\n          {\n            role: 'user',\n            content: `Analyze the sentiment of this feedback: \"${feedbackText}\". Respond with a JSON object with the format {\"sentiment\": \"Positive/Negative/Neutral\", \"confidence\": 0.X} where confidence is a number between 0 and 1.`\n          }\n        ],\n        temperature: 0.3,\n        max_tokens: 100\n      },\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${API_KEY}`\n        }\n      }\n    );\n\n    // Parse the response to extract the sentiment\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\{.*\\}/s);\n    \n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse sentiment from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error analyzing sentiment with OpenAI:', error);\n    return mockAnalyzeSentiment(feedbackText);\n  }\n};\n\n/**\n * Batch analyze sentiment for multiple feedback texts\n * @param {Array} feedbackItems - Array of feedback objects\n * @returns {Promise<Object>} - Mapping of feedback IDs to sentiment\n */\nexport const batchAnalyzeSentiment = async (feedbackItems) => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback sentiment analysis.');\n      return fallbackBatchSentiment(feedbackItems);\n    }\n\n    // Prepare the batch prompt\n    const feedbackTexts = feedbackItems.map((item, index) => \n      `Feedback ${index + 1}: \"${item.text}\"`\n    ).join('\\n\\n');\n\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-3.5-turbo-16k',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are an assistant that analyzes the sentiment of multiple pieces of user feedback. Classify each as Positive, Negative, or Neutral.'\n          },\n          {\n            role: 'user',\n            content: `Analyze the sentiment of each of these feedback items:\\n\\n${feedbackTexts}\\n\\nRespond with a JSON array with the format [{\"feedbackIndex\": 1, \"sentiment\": \"Positive/Negative/Neutral\"}, {\"feedbackIndex\": 2, \"sentiment\": \"Positive/Negative/Neutral\"}, ...] for each feedback item.`\n          }\n        ],\n        temperature: 0.3,\n        max_tokens: 2000\n      },\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${API_KEY}`\n        }\n      }\n    );\n\n    // Parse the response to extract the sentiments\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\[\\s*\\{.*\\}\\s*\\]/s);\n    \n    if (match) {\n      const results = JSON.parse(match[0]);\n      \n      // Create a mapping of feedback ID to sentiment\n      const sentimentMap = {};\n      results.forEach(result => {\n        const feedbackItem = feedbackItems[result.feedbackIndex - 1];\n        if (feedbackItem) {\n          sentimentMap[feedbackItem.id] = result.sentiment;\n        }\n      });\n      \n      return sentimentMap;\n    } else {\n      throw new Error('Could not parse sentiments from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error batch analyzing sentiment with OpenAI:', error);\n    return fallbackBatchSentiment(feedbackItems);\n  }\n};\n\n/**\n * Fallback function for batch classification\n * @param {Array} feedbackItems - Array of feedback objects\n * @returns {Object} - Mapping of feedback IDs to themes\n */\nconst fallbackBatchClassify = (feedbackItems) => {\n  const themeMap = {};\n  feedbackItems.forEach(item => {\n    const result = mockClassifyFeedback(item.text);\n    themeMap[item.id] = result.theme;\n  });\n  return themeMap;\n};\n\n/**\n * Mock function for keyword-based theme classification (used as fallback)\n * @param {string} text - The feedback text to classify\n * @returns {Object} - An object containing the theme\n */\nconst mockClassifyFeedback = (text) => {\n  const lowerText = text.toLowerCase();\n  \n  if (lowerText.includes('crash') || lowerText.includes('error') || lowerText.includes('bug')) {\n    return { theme: 'Error Handling' };\n  } else if (lowerText.includes('slow') || lowerText.includes('performance') || lowerText.includes('timeout') || lowerText.includes('load')) {\n    return { theme: 'Performance' };\n  } else if (lowerText.includes('mobile') || lowerText.includes('app') || lowerText.includes('phone')) {\n    return { theme: 'Mobile Experience' };\n  } else if (lowerText.includes('ui') || lowerText.includes('interface') || lowerText.includes('design') || \n            lowerText.includes('layout') || lowerText.includes('look')) {\n    return { theme: 'Design' };\n  } else if (lowerText.includes('report') || lowerText.includes('dashboard')) {\n    return { theme: 'Data Visualization' };\n  } else if (lowerText.includes('export') || lowerText.includes('excel') || lowerText.includes('pdf')) {\n    return { theme: 'Data Export' };\n  } else if (lowerText.includes('search') || lowerText.includes('filter') || lowerText.includes('find')) {\n    return { theme: 'Navigation' };\n  } else if (lowerText.includes('easy') || lowerText.includes('difficult') || lowerText.includes('confusing') || \n            lowerText.includes('intuitive') || lowerText.includes('user-friendly')) {\n    return { theme: 'Usability' };\n  } else if (lowerText.includes('feature') || lowerText.includes('function') || lowerText.includes('capability')) {\n    return { theme: 'Functionality' };\n  }\n  \n  return { theme: 'General Feedback' };\n};\n\n/**\n * Mock function for feature idea generation (used as fallback)\n * @param {string} theme - The theme to generate feature ideas for\n * @returns {Array} - Array of feature ideas\n */\nconst mockGenerateFeatureIdeas = (theme) => {\n  switch (theme) {\n    case 'Error Handling':\n      return [\n        { \n          name: 'Intelligent Error Recovery', \n          description: 'Automatically recover from common errors without user intervention',\n          priority: 'High'\n        },\n        {\n          name: 'User-Friendly Error Messages',\n          description: 'Replace technical error messages with clear action items for users',\n          priority: 'Medium'\n        }\n      ];\n    case 'Performance':\n      return [\n        { \n          name: 'Optimized Data Loading', \n          description: 'Implement progressive loading and caching for faster dashboard performance',\n          priority: 'High'\n        },\n        {\n          name: 'Background Processing',\n          description: 'Move heavy calculations to background threads to keep UI responsive',\n          priority: 'Medium'\n        }\n      ];\n    case 'Design':\n      return [\n        { \n          name: 'Redesigned Interface', \n          description: 'Streamline UI with modern design principles and improved visual hierarchy',\n          priority: 'Medium'\n        },\n        {\n          name: 'Customizable Themes',\n          description: 'Allow users to personalize the interface with color themes and layouts',\n          priority: 'Low'\n        }\n      ];\n    default:\n      return [\n        { \n          name: `${theme} Improvements`, \n          description: `Address user feedback related to ${theme.toLowerCase()}`,\n          priority: 'Medium'\n        },\n        {\n          name: 'User Experience Enhancement',\n          description: 'General improvements based on feedback analysis',\n          priority: 'Medium'\n        }\n      ];\n  }\n};\n\n/**\n * Fallback function for batch sentiment analysis\n */\nconst fallbackBatchSentiment = (feedbackItems) => {\n  const sentimentMap = {};\n  feedbackItems.forEach(item => {\n    const result = mockAnalyzeSentiment(item.text);\n    sentimentMap[item.id] = result.sentiment;\n  });\n  return sentimentMap;\n};\n\n/**\n * Mock function for sentiment analysis (used as fallback)\n */\nconst mockAnalyzeSentiment = (text) => {\n  const lowerText = text.toLowerCase();\n  \n  // Simple keyword-based sentiment analysis\n  const positiveWords = ['love', 'great', 'good', 'amazing', 'excellent', 'awesome', 'fantastic', 'helpful', 'best', 'easy', 'like', 'impressed'];\n  const negativeWords = ['bad', 'terrible', 'awful', 'poor', 'difficult', 'annoying', 'frustrating', 'hate', 'slow', 'worst', 'broken', 'issue', 'problem', 'error', 'bug'];\n  \n  let positiveCount = 0;\n  let negativeCount = 0;\n  \n  positiveWords.forEach(word => {\n    if (lowerText.includes(word)) positiveCount++;\n  });\n  \n  negativeWords.forEach(word => {\n    if (lowerText.includes(word)) negativeCount++;\n  });\n  \n  if (positiveCount > negativeCount) {\n    return { sentiment: 'Positive', confidence: 0.7 };\n  } else if (negativeCount > positiveCount) {\n    return { sentiment: 'Negative', confidence: 0.7 };\n  } else {\n    return { sentiment: 'Neutral', confidence: 0.5 };\n  }\n};\n\n/**\n * Generate insights for a specific persona\n * @param {Object} persona - The persona node data\n * @param {Array} relatedFeedback - Feedback from this persona\n * @param {Array} connectedThemes - Themes this persona is connected to\n * @returns {Promise<Object>} AI insights about this persona\n */\nexport const analyzePersona = async (persona, relatedFeedback, connectedThemes) => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback persona analysis.');\n      return mockPersonaAnalysis(persona, relatedFeedback, connectedThemes);\n    }\n\n    // Extract feedback text for context\n    const feedbackTexts = relatedFeedback.map(f => f.text).join('\\n• ');\n    const themeNames = connectedThemes.map(t => t.name).join(', ');\n\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-3.5-turbo',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are a user research analyst who provides concise, actionable insights about user personas based on their feedback.'\n          },\n          {\n            role: 'user',\n            content: `Analyze this \"${persona.name}\" user persona and their feedback:\\n\\nRole: ${persona.name}\\nTotal Feedback: ${persona.feedbackCount}\\nMain Themes: ${themeNames}\\n\\nSample Feedback:\\n• ${feedbackTexts}\\n\\nProvide insights in JSON format with these fields:\\n1. \"patterns\" - Key patterns in their feedback (1-2 sentences)\\n2. \"painPoints\" - Their main pain points (1-2 sentences)\\n3. \"suggestions\" - 2-3 specific improvements for this user type (short bullet points)\\n4. \"priority\" - How to prioritize addressing their needs (High/Medium/Low with brief justification)`\n          }\n        ],\n        temperature: 0.5,\n        max_tokens: 600\n      },\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${API_KEY}`\n        }\n      }\n    );\n\n    // Parse response\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\{.*\\}/s);\n    \n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse persona analysis from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error analyzing persona with OpenAI:', error);\n    return mockPersonaAnalysis(persona, relatedFeedback, connectedThemes);\n  }\n};\n\n/**\n * Generate insights for a specific theme\n * @param {Object} theme - The theme node data\n * @param {Array} relatedFeedback - Feedback related to this theme\n * @param {Array} connectedPersonas - Personas connected to this theme\n * @returns {Promise<Object>} AI insights about this theme\n */\nexport const analyzeTheme = async (theme, relatedFeedback, connectedPersonas) => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback theme analysis.');\n      return mockThemeAnalysis(theme, relatedFeedback, connectedPersonas);\n    }\n\n    // Calculate sentiment distribution for context\n    const sentimentCounts = { Positive: 0, Negative: 0, Neutral: 0 };\n    relatedFeedback.forEach(f => {\n      sentimentCounts[f.sentiment || 'Neutral']++;\n    });\n    \n    // Extract sample feedback text\n    const sampleFeedback = relatedFeedback.slice(0, 5).map(f => \n      `• ${f.text} (Sentiment: ${f.sentiment || 'Neutral'})`\n    ).join('\\n');\n    \n    const personaNames = connectedPersonas.map(p => p.name).join(', ');\n\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-3.5-turbo',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are a product analyst who provides concise, actionable insights about product themes based on user feedback.'\n          },\n          {\n            role: 'user',\n            content: `Analyze the \"${theme.name}\" theme based on this feedback:\\n\\nFeedback Count: ${theme.feedbackCount}\\nSentiment: ${sentimentCounts.Positive} positive, ${sentimentCounts.Negative} negative, ${sentimentCounts.Neutral} neutral\\nUser Types: ${personaNames}\\n\\nSample Feedback:\\n${sampleFeedback}\\n\\nProvide insights in JSON format with these fields:\\n1. \"trends\" - Key trends in the feedback about this theme (1-2 sentences)\\n2. \"priority\" - How urgent is addressing this theme (High/Medium/Low with brief justification)\\n3. \"solutions\" - 2-3 specific potential solutions (short bullet points)\\n4. \"impact\" - The potential impact of addressing this theme (1-2 sentences)`\n          }\n        ],\n        temperature: 0.5,\n        max_tokens: 600\n      },\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${API_KEY}`\n        }\n      }\n    );\n\n    // Parse response\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\{.*\\}/s);\n    \n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse theme analysis from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error analyzing theme with OpenAI:', error);\n    return mockThemeAnalysis(theme, relatedFeedback, connectedPersonas);\n  }\n};\n\n/**\n * Generate insights for a specific feedback item\n * @param {Object} feedback - The feedback node data\n * @param {Array} similarFeedback - Similar feedback items\n * @returns {Promise<Object>} AI insights about this feedback\n */\nexport const analyzeFeedback = async (feedback, similarFeedback = []) => {\n  try {\n    if (!API_KEY) {\n      console.warn('OpenAI API key is missing. Using fallback feedback analysis.');\n      return mockFeedbackAnalysis(feedback);\n    }\n\n    // Extract similar feedback for context\n    const similarFeedbackText = similarFeedback.slice(0, 3).map(f => \n      `• ${f.text}`\n    ).join('\\n');\n\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-3.5-turbo',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are a customer feedback analyst who provides concise, actionable insights about individual pieces of feedback.'\n          },\n          {\n            role: 'user',\n            content: `Analyze this feedback item:\\n\\nFeedback: \"${feedback.title || feedback.text}\"\\nUser Role: ${feedback.user_role || 'Unknown'}\\nTheme: ${feedback.theme || 'Unclassified'}\\n${similarFeedbackText ? `\\nSimilar Feedback:\\n${similarFeedbackText}` : ''}\\n\\nProvide insights in JSON format with these fields:\\n1. \"sentiment\" - A precise sentiment analysis (Very Positive/Positive/Neutral/Negative/Very Negative)\\n2. \"keyPoints\" - The main points of this feedback (1-2 sentences)\\n3. \"actionItems\" - 1-3 specific actions to address this feedback (short bullet points)\\n4. \"broader\" - How this feedback relates to broader product/service issues (1 sentence)`\n          }\n        ],\n        temperature: 0.5,\n        max_tokens: 500\n      },\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${API_KEY}`\n        }\n      }\n    );\n\n    // Parse response\n    const assistantMessage = response.data.choices[0].message.content;\n    const match = assistantMessage.match(/\\{.*\\}/s);\n    \n    if (match) {\n      return JSON.parse(match[0]);\n    } else {\n      throw new Error('Could not parse feedback analysis from OpenAI response');\n    }\n  } catch (error) {\n    console.error('Error analyzing feedback with OpenAI:', error);\n    return mockFeedbackAnalysis(feedback);\n  }\n};\n\n/**\n * Mock persona analysis for fallback\n */\nconst mockPersonaAnalysis = (persona, relatedFeedback, connectedThemes) => {\n  return {\n    patterns: `${persona.name} users primarily focus on ${connectedThemes.length > 0 ? connectedThemes[0].name.toLowerCase() : 'functionality'} and efficiency in their feedback.`,\n    painPoints: `Main frustrations appear to be around ${relatedFeedback.length > 0 ? relatedFeedback[0].theme?.toLowerCase() || 'usability' : 'usability'} issues and learning curve challenges.`,\n    suggestions: [\n      \"Improve onboarding for this user type\",\n      \"Streamline their most-used workflows\",\n      `Enhance ${connectedThemes.length > 0 ? connectedThemes[0].name.toLowerCase() : 'core features'} specifically for ${persona.name} users`\n    ],\n    priority: persona.feedbackCount > 10 ? \"High - large user segment with significant pain points\" : \"Medium - address after critical issues\"\n  };\n};\n\n/**\n * Mock theme analysis for fallback\n */\nconst mockThemeAnalysis = (theme, relatedFeedback, connectedPersonas) => {\n  const isNegative = relatedFeedback.filter(f => f.sentiment === 'Negative').length > \n                     relatedFeedback.filter(f => f.sentiment === 'Positive').length;\n  \n  return {\n    trends: `User feedback on ${theme.name} shows ${isNegative ? 'consistent frustration with current implementation' : 'mixed but generally positive reactions'}.`,\n    priority: isNegative ? \"High - significant user frustration in this area\" : \"Medium - improvements would enhance user experience\",\n    solutions: [\n      `Redesign the ${theme.name.toLowerCase()} interface for clarity`,\n      \"Add additional user guidance and tooltips\",\n      \"Implement automated error recovery\"\n    ],\n    impact: `Addressing ${theme.name.toLowerCase()} issues would improve satisfaction for ${connectedPersonas.length} user types and potentially reduce support tickets.`\n  };\n};\n\n/**\n * Mock feedback analysis for fallback\n */\nconst mockFeedbackAnalysis = (feedback) => {\n  const isNegative = feedback.sentiment === 'Negative';\n  \n  return {\n    sentiment: isNegative ? \"Negative\" : (feedback.sentiment === 'Positive' ? \"Positive\" : \"Neutral\"),\n    keyPoints: `This feedback ${isNegative ? 'highlights frustration with' : 'comments on'} ${feedback.theme?.toLowerCase() || 'the product'}.`,\n    actionItems: [\n      `Review the ${feedback.theme?.toLowerCase() || 'mentioned feature'} functionality`,\n      \"Compare with similar user feedback\",\n      isNegative ? \"Consider for next sprint prioritization\" : \"Note as positive feedback\"\n    ],\n    broader: `This feedback relates to broader ${feedback.theme?.toLowerCase() || 'user experience'} considerations in the product.`\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}