{"ast":null,"code":"import { v4 as uuidv4 } from 'uuid';\nimport { batchClassifyFeedback, generateFeatureIdeas, batchAnalyzeSentiment } from '../services/openaiService';\n\n/**\n * Process feedback data to extract themes and create visualization data\n * @param {Array} feedbackData - The raw feedback data array\n * @returns {Promise<Object>} Object containing nodes, links, and AI insights\n */\nexport const processFeedbackData = async feedbackData => {\n  if (!feedbackData || !Array.isArray(feedbackData)) {\n    console.error('Invalid feedback data format');\n    return {\n      nodes: [],\n      links: [],\n      insights: []\n    };\n  }\n\n  // Use OpenAI to classify feedback into themes\n  console.log(\"Classifying feedback with OpenAI...\");\n  const themeMap = await batchClassifyFeedback(feedbackData);\n\n  // Use OpenAI to analyze sentiment of feedback\n  console.log(\"Analyzing sentiment with OpenAI...\");\n  const sentimentMap = await batchAnalyzeSentiment(feedbackData);\n\n  // Extract unique themes from the classification results\n  const themes = [...new Set(Object.values(themeMap))];\n  console.log(\"Extracted themes:\", themes);\n\n  // Create nodes for each feedback item, theme, and persona\n  const nodes = createNodes(feedbackData, themes, themeMap, sentimentMap);\n\n  // Create links between feedback and related themes/personas\n  const links = createLinks(feedbackData, themes, nodes, themeMap);\n\n  // Generate AI insights from the feedback\n  const insights = await generateInsights(feedbackData, themes, themeMap, sentimentMap);\n\n  // Generate additional analytical data for the AI panel\n  const analyticsData = generateAnalytics(feedbackData, themeMap, sentimentMap);\n  return {\n    nodes,\n    links,\n    insights,\n    analytics: analyticsData\n  };\n};\n\n/**\n * Create nodes for visualization\n */\nconst createNodes = (feedbackData, themes, themeMap, sentimentMap) => {\n  const nodes = [];\n\n  // Create theme nodes\n  themes.forEach(theme => {\n    // Count how many feedback items belong to this theme\n    const themeCount = Object.values(themeMap).filter(t => t === theme).length;\n    nodes.push({\n      id: `theme-${theme.replace(/\\s+/g, '-').toLowerCase()}`,\n      type: 'theme',\n      name: theme,\n      label: theme,\n      feedbackCount: themeCount,\n      value: 25 + themeCount * 2,\n      // Scale size based on feedback count\n      group: 'theme'\n    });\n  });\n\n  // Create persona nodes from feedback user_roles\n  const uniqueRoles = [...new Set(feedbackData.map(item => item.user_role).filter(Boolean))];\n  uniqueRoles.forEach(role => {\n    // Count how many feedback items are from this persona\n    const roleCount = feedbackData.filter(item => item.user_role === role).length;\n\n    // Calculate sentiment for this role\n    const roleFeedback = feedbackData.filter(item => item.user_role === role);\n    let positiveCount = 0,\n      negativeCount = 0,\n      neutralCount = 0;\n    roleFeedback.forEach(feedback => {\n      const sentiment = sentimentMap[feedback.id];\n      if (sentiment === 'Positive') positiveCount++;else if (sentiment === 'Negative') negativeCount++;else neutralCount++;\n    });\n    nodes.push({\n      id: `persona-${role.replace(/\\s+/g, '-').toLowerCase()}`,\n      type: 'persona',\n      name: role,\n      label: role,\n      feedbackCount: roleCount,\n      value: 20,\n      group: 'persona',\n      sentimentStats: {\n        positive: positiveCount,\n        negative: negativeCount,\n        neutral: neutralCount\n      }\n    });\n  });\n\n  // Create feedback nodes with more aggressive text truncation\n  feedbackData.forEach(feedback => {\n    nodes.push({\n      id: feedback.id,\n      type: 'feedback',\n      name: truncateText(feedback.text, 20),\n      // More aggressive truncation\n      label: truncateText(feedback.text, 20),\n      title: feedback.text,\n      // Full text stored for tooltip/details\n      value: 15,\n      group: feedback.user_role || 'unknown',\n      timestamp: feedback.timestamp,\n      user_role: feedback.user_role,\n      theme: themeMap[feedback.id] || 'Unclassified',\n      sentiment: sentimentMap[feedback.id] || 'Neutral'\n    });\n  });\n  return nodes;\n};\n\n/**\n * Create links between nodes\n */\nconst createLinks = (feedbackData, themes, nodes, themeMap) => {\n  const links = [];\n\n  // Connect feedback to relevant themes based on AI classification\n  feedbackData.forEach(feedback => {\n    const feedbackTheme = themeMap[feedback.id];\n    if (feedbackTheme) {\n      const themeId = `theme-${feedbackTheme.replace(/\\s+/g, '-').toLowerCase()}`;\n      links.push({\n        id: uuidv4(),\n        source: feedback.id,\n        target: themeId,\n        strength: 0.8\n      });\n    }\n\n    // Connect feedback to persona (user role)\n    if (feedback.user_role) {\n      const personaId = `persona-${feedback.user_role.replace(/\\s+/g, '-').toLowerCase()}`;\n      links.push({\n        id: uuidv4(),\n        source: feedback.id,\n        target: personaId,\n        strength: 0.7\n      });\n    }\n  });\n\n  // Connect personas to themes they have feedback about\n  const personaNodes = nodes.filter(node => node.type === 'persona');\n  const themeNodes = nodes.filter(node => node.type === 'theme');\n  personaNodes.forEach(persona => {\n    // Find all feedback from this persona\n    const personaFeedback = feedbackData.filter(f => f.user_role && f.user_role.replace(/\\s+/g, '-').toLowerCase() === persona.id.replace('persona-', ''));\n\n    // Find themes associated with this feedback\n    const personaThemes = new Set();\n    personaFeedback.forEach(feedback => {\n      const theme = themeMap[feedback.id];\n      if (theme) personaThemes.add(theme);\n    });\n\n    // Connect persona to each theme\n    themeNodes.forEach(theme => {\n      const themeName = theme.name;\n      if (personaThemes.has(themeName)) {\n        links.push({\n          id: uuidv4(),\n          source: persona.id,\n          target: theme.id,\n          strength: 0.6 // Slightly weaker connection\n        });\n      }\n    });\n  });\n  return links;\n};\n\n/**\n * Generate comprehensive analytics from feedback data\n */\nconst generateAnalytics = (feedbackData, themeMap, sentimentMap) => {\n  // Overall sentiment distribution\n  const sentimentCounts = {\n    Positive: 0,\n    Negative: 0,\n    Neutral: 0\n  };\n  Object.values(sentimentMap).forEach(sentiment => {\n    sentimentCounts[sentiment]++;\n  });\n\n  // Theme distribution\n  const themeCounts = {};\n  Object.values(themeMap).forEach(theme => {\n    themeCounts[theme] = (themeCounts[theme] || 0) + 1;\n  });\n\n  // Sentiment by theme\n  const sentimentByTheme = {};\n  feedbackData.forEach(feedback => {\n    const theme = themeMap[feedback.id];\n    const sentiment = sentimentMap[feedback.id];\n    if (!theme || !sentiment) return;\n    if (!sentimentByTheme[theme]) {\n      sentimentByTheme[theme] = {\n        Positive: 0,\n        Negative: 0,\n        Neutral: 0\n      };\n    }\n    sentimentByTheme[theme][sentiment]++;\n  });\n\n  // User role distribution\n  const roleCounts = {};\n  feedbackData.forEach(feedback => {\n    if (feedback.user_role) {\n      roleCounts[feedback.user_role] = (roleCounts[feedback.user_role] || 0) + 1;\n    }\n  });\n\n  // Sentiment by user role\n  const sentimentByRole = {};\n  feedbackData.forEach(feedback => {\n    const role = feedback.user_role;\n    const sentiment = sentimentMap[feedback.id];\n    if (!role || !sentiment) return;\n    if (!sentimentByRole[role]) {\n      sentimentByRole[role] = {\n        Positive: 0,\n        Negative: 0,\n        Neutral: 0\n      };\n    }\n    sentimentByRole[role][sentiment]++;\n  });\n\n  // Feedback over time (if timestamp is available)\n  const feedbackByDate = {};\n  feedbackData.forEach(feedback => {\n    if (feedback.timestamp) {\n      const date = new Date(feedback.timestamp).toISOString().split('T')[0];\n      feedbackByDate[date] = (feedbackByDate[date] || 0) + 1;\n    }\n  });\n  return {\n    totalFeedback: feedbackData.length,\n    sentimentDistribution: sentimentCounts,\n    themeDistribution: themeCounts,\n    sentimentByTheme,\n    roleDistribution: roleCounts,\n    sentimentByRole,\n    feedbackByDate\n  };\n};\n\n/**\n * Generate AI insights from feedback\n */\nconst generateInsights = async (feedbackData, themes, themeMap, sentimentMap) => {\n  const insights = [];\n\n  // Create a map of themes to feedback\n  const themeToFeedback = {};\n  feedbackData.forEach(feedback => {\n    const theme = themeMap[feedback.id];\n    if (theme) {\n      if (!themeToFeedback[theme]) {\n        themeToFeedback[theme] = [];\n      }\n      themeToFeedback[theme].push({\n        text: feedback.text,\n        sentiment: sentimentMap[feedback.id] || 'Neutral'\n      });\n    }\n  });\n\n  // Generate insights for top themes\n  const topThemes = Object.entries(themeToFeedback).sort((a, b) => b[1].length - a[1].length).slice(0, 5) // Show more themes\n  .map(([theme]) => theme);\n\n  // Add overview insight first\n  const sentimentCounts = {\n    Positive: 0,\n    Negative: 0,\n    Neutral: 0\n  };\n  Object.values(sentimentMap).forEach(sentiment => {\n    sentimentCounts[sentiment]++;\n  });\n  insights.push({\n    id: uuidv4(),\n    title: 'Feedback Overview',\n    description: `Analyzed ${feedbackData.length} pieces of feedback across ${themes.length} key themes. Overall sentiment: ${sentimentCounts.Positive} positive, ${sentimentCounts.Negative} negative, and ${sentimentCounts.Neutral} neutral feedback items.`\n  });\n  for (const theme of topThemes) {\n    var _feedbackItems$filter, _feedbackItems$filter2;\n    const feedbackItems = themeToFeedback[theme];\n    const feedbackCount = feedbackItems.length;\n\n    // Calculate sentiment distribution for this theme\n    const themeSentiment = {\n      Positive: 0,\n      Negative: 0,\n      Neutral: 0\n    };\n    feedbackItems.forEach(item => {\n      themeSentiment[item.sentiment]++;\n    });\n\n    // Find representative examples of both positive and negative feedback\n    const positiveFeedback = (_feedbackItems$filter = feedbackItems.filter(item => item.sentiment === 'Positive')[0]) === null || _feedbackItems$filter === void 0 ? void 0 : _feedbackItems$filter.text;\n    const negativeFeedback = (_feedbackItems$filter2 = feedbackItems.filter(item => item.sentiment === 'Negative')[0]) === null || _feedbackItems$filter2 === void 0 ? void 0 : _feedbackItems$filter2.text;\n    const examples = [];\n    if (positiveFeedback) examples.push(`Positive: \"${truncateText(positiveFeedback, 60)}\"`);\n    if (negativeFeedback) examples.push(`Negative: \"${truncateText(negativeFeedback, 60)}\"`);\n    const sentimentSummary = `Sentiment: ${themeSentiment.Positive} positive, ${themeSentiment.Negative} negative, ${themeSentiment.Neutral} neutral`;\n\n    // Add theme-specific insight with sentiment analysis\n    insights.push({\n      id: uuidv4(),\n      title: `${theme}`,\n      description: `${feedbackCount} feedback items were identified in this theme. ${sentimentSummary}. ${examples.length > 0 ? 'Examples include: ' + examples.join('; ') : ''}`,\n      sentiment: themeSentiment,\n      feedbackCount\n    });\n  }\n\n  // Add role-based insight\n  const roles = [...new Set(feedbackData.map(item => item.user_role).filter(Boolean))];\n  if (roles.length > 0) {\n    // Calculate sentiment by role\n    const sentimentByRole = {};\n    feedbackData.forEach(feedback => {\n      const role = feedback.user_role;\n      const sentiment = sentimentMap[feedback.id];\n      if (!role || !sentiment) return;\n      if (!sentimentByRole[role]) {\n        sentimentByRole[role] = {\n          Positive: 0,\n          Negative: 0,\n          Neutral: 0\n        };\n      }\n      sentimentByRole[role][sentiment]++;\n    });\n\n    // Find the role with the most negative sentiment\n    let mostNegativeRole = '';\n    let highestNegativePercentage = 0;\n    Object.entries(sentimentByRole).forEach(([role, counts]) => {\n      const total = counts.Positive + counts.Negative + counts.Neutral;\n      const negativePercentage = counts.Negative / total;\n      if (negativePercentage > highestNegativePercentage) {\n        highestNegativePercentage = negativePercentage;\n        mostNegativeRole = role;\n      }\n    });\n    insights.push({\n      id: uuidv4(),\n      title: 'User Role Analysis',\n      description: `Feedback came from ${roles.length} different user roles. ${mostNegativeRole ? `${mostNegativeRole} users expressed the most concerns, with ${Math.round(highestNegativePercentage * 100)}% negative feedback.` : ''}`\n    });\n  }\n  return insights;\n};\n\n/**\n * Helper function to truncate text\n */\nconst truncateText = (text, maxLength) => {\n  if (!text) return \"No text\";\n  if (text.length <= maxLength) return text;\n\n  // For longer texts, try to find a good breaking point\n  const breakPoint = text.lastIndexOf(' ', maxLength - 3);\n  if (breakPoint > maxLength / 2) {\n    return text.substring(0, breakPoint) + '...';\n  }\n  return text.substring(0, maxLength) + '...';\n};\n\n/**\n * Import and process JSON feedback data\n * @param {File|String} source - Either a File object or a JSON string\n * @returns {Promise} Promise that resolves to processed data\n */\nexport const importFeedbackData = async source => {\n  try {\n    let data;\n    if (typeof source === 'string') {\n      // If the source is a JSON string\n      data = JSON.parse(source);\n    } else if (source instanceof File) {\n      // If the source is a File object\n      const text = await readFileAsText(source);\n      data = JSON.parse(text);\n    } else {\n      throw new Error('Invalid source type. Expected File or JSON string.');\n    }\n\n    // If the data is not an array but has a property that is an array\n    if (!Array.isArray(data)) {\n      // Look for a property that might contain the feedback array\n      const possibleArrayProps = Object.keys(data).filter(key => Array.isArray(data[key]));\n      if (possibleArrayProps.length > 0) {\n        data = data[possibleArrayProps[0]];\n      } else {\n        throw new Error('Could not find feedback data array in the imported JSON.');\n      }\n    }\n\n    // Process the data with AI classification\n    return await processFeedbackData(data);\n  } catch (error) {\n    console.error('Error importing feedback data:', error);\n    throw error;\n  }\n};\n\n/**\n * Read a file as text\n */\nconst readFileAsText = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result);\n    reader.onerror = reject;\n    reader.readAsText(file);\n  });\n};","map":{"version":3,"names":["v4","uuidv4","batchClassifyFeedback","generateFeatureIdeas","batchAnalyzeSentiment","processFeedbackData","feedbackData","Array","isArray","console","error","nodes","links","insights","log","themeMap","sentimentMap","themes","Set","Object","values","createNodes","createLinks","generateInsights","analyticsData","generateAnalytics","analytics","forEach","theme","themeCount","filter","t","length","push","id","replace","toLowerCase","type","name","label","feedbackCount","value","group","uniqueRoles","map","item","user_role","Boolean","role","roleCount","roleFeedback","positiveCount","negativeCount","neutralCount","feedback","sentiment","sentimentStats","positive","negative","neutral","truncateText","text","title","timestamp","feedbackTheme","themeId","source","target","strength","personaId","personaNodes","node","themeNodes","persona","personaFeedback","f","personaThemes","add","themeName","has","sentimentCounts","Positive","Negative","Neutral","themeCounts","sentimentByTheme","roleCounts","sentimentByRole","feedbackByDate","date","Date","toISOString","split","totalFeedback","sentimentDistribution","themeDistribution","roleDistribution","themeToFeedback","topThemes","entries","sort","a","b","slice","description","_feedbackItems$filter","_feedbackItems$filter2","feedbackItems","themeSentiment","positiveFeedback","negativeFeedback","examples","sentimentSummary","join","roles","mostNegativeRole","highestNegativePercentage","counts","total","negativePercentage","Math","round","maxLength","breakPoint","lastIndexOf","substring","importFeedbackData","data","JSON","parse","File","readFileAsText","Error","possibleArrayProps","keys","key","file","Promise","resolve","reject","reader","FileReader","onload","result","onerror","readAsText"],"sources":["/Users/faisalshariff/Feedback Force/src/utils/importData.js"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid';\nimport { batchClassifyFeedback, generateFeatureIdeas, batchAnalyzeSentiment } from '../services/openaiService';\n\n/**\n * Process feedback data to extract themes and create visualization data\n * @param {Array} feedbackData - The raw feedback data array\n * @returns {Promise<Object>} Object containing nodes, links, and AI insights\n */\nexport const processFeedbackData = async (feedbackData) => {\n  if (!feedbackData || !Array.isArray(feedbackData)) {\n    console.error('Invalid feedback data format');\n    return { nodes: [], links: [], insights: [] };\n  }\n\n  // Use OpenAI to classify feedback into themes\n  console.log(\"Classifying feedback with OpenAI...\");\n  const themeMap = await batchClassifyFeedback(feedbackData);\n  \n  // Use OpenAI to analyze sentiment of feedback\n  console.log(\"Analyzing sentiment with OpenAI...\");\n  const sentimentMap = await batchAnalyzeSentiment(feedbackData);\n  \n  // Extract unique themes from the classification results\n  const themes = [...new Set(Object.values(themeMap))];\n  console.log(\"Extracted themes:\", themes);\n  \n  // Create nodes for each feedback item, theme, and persona\n  const nodes = createNodes(feedbackData, themes, themeMap, sentimentMap);\n  \n  // Create links between feedback and related themes/personas\n  const links = createLinks(feedbackData, themes, nodes, themeMap);\n  \n  // Generate AI insights from the feedback\n  const insights = await generateInsights(feedbackData, themes, themeMap, sentimentMap);\n  \n  // Generate additional analytical data for the AI panel\n  const analyticsData = generateAnalytics(feedbackData, themeMap, sentimentMap);\n  \n  return { nodes, links, insights, analytics: analyticsData };\n};\n\n/**\n * Create nodes for visualization\n */\nconst createNodes = (feedbackData, themes, themeMap, sentimentMap) => {\n  const nodes = [];\n  \n  // Create theme nodes\n  themes.forEach(theme => {\n    // Count how many feedback items belong to this theme\n    const themeCount = Object.values(themeMap).filter(t => t === theme).length;\n    \n    nodes.push({\n      id: `theme-${theme.replace(/\\s+/g, '-').toLowerCase()}`,\n      type: 'theme',\n      name: theme,\n      label: theme,\n      feedbackCount: themeCount,\n      value: 25 + (themeCount * 2), // Scale size based on feedback count\n      group: 'theme'\n    });\n  });\n  \n  // Create persona nodes from feedback user_roles\n  const uniqueRoles = [...new Set(feedbackData.map(item => item.user_role).filter(Boolean))];\n  uniqueRoles.forEach(role => {\n    // Count how many feedback items are from this persona\n    const roleCount = feedbackData.filter(item => item.user_role === role).length;\n    \n    // Calculate sentiment for this role\n    const roleFeedback = feedbackData.filter(item => item.user_role === role);\n    let positiveCount = 0, negativeCount = 0, neutralCount = 0;\n    \n    roleFeedback.forEach(feedback => {\n      const sentiment = sentimentMap[feedback.id];\n      if (sentiment === 'Positive') positiveCount++;\n      else if (sentiment === 'Negative') negativeCount++;\n      else neutralCount++;\n    });\n    \n    nodes.push({\n      id: `persona-${role.replace(/\\s+/g, '-').toLowerCase()}`,\n      type: 'persona',\n      name: role,\n      label: role,\n      feedbackCount: roleCount,\n      value: 20,\n      group: 'persona',\n      sentimentStats: {\n        positive: positiveCount,\n        negative: negativeCount,\n        neutral: neutralCount\n      }\n    });\n  });\n  \n  // Create feedback nodes with more aggressive text truncation\n  feedbackData.forEach(feedback => {\n    nodes.push({\n      id: feedback.id,\n      type: 'feedback',\n      name: truncateText(feedback.text, 20), // More aggressive truncation\n      label: truncateText(feedback.text, 20),\n      title: feedback.text, // Full text stored for tooltip/details\n      value: 15,\n      group: feedback.user_role || 'unknown',\n      timestamp: feedback.timestamp,\n      user_role: feedback.user_role,\n      theme: themeMap[feedback.id] || 'Unclassified',\n      sentiment: sentimentMap[feedback.id] || 'Neutral'\n    });\n  });\n  \n  return nodes;\n};\n\n/**\n * Create links between nodes\n */\nconst createLinks = (feedbackData, themes, nodes, themeMap) => {\n  const links = [];\n  \n  // Connect feedback to relevant themes based on AI classification\n  feedbackData.forEach(feedback => {\n    const feedbackTheme = themeMap[feedback.id];\n    if (feedbackTheme) {\n      const themeId = `theme-${feedbackTheme.replace(/\\s+/g, '-').toLowerCase()}`;\n      links.push({\n        id: uuidv4(),\n        source: feedback.id,\n        target: themeId,\n        strength: 0.8\n      });\n    }\n    \n    // Connect feedback to persona (user role)\n    if (feedback.user_role) {\n      const personaId = `persona-${feedback.user_role.replace(/\\s+/g, '-').toLowerCase()}`;\n      links.push({\n        id: uuidv4(),\n        source: feedback.id,\n        target: personaId,\n        strength: 0.7\n      });\n    }\n  });\n  \n  // Connect personas to themes they have feedback about\n  const personaNodes = nodes.filter(node => node.type === 'persona');\n  const themeNodes = nodes.filter(node => node.type === 'theme');\n  \n  personaNodes.forEach(persona => {\n    // Find all feedback from this persona\n    const personaFeedback = feedbackData.filter(f => \n      f.user_role && f.user_role.replace(/\\s+/g, '-').toLowerCase() === persona.id.replace('persona-', '')\n    );\n    \n    // Find themes associated with this feedback\n    const personaThemes = new Set();\n    personaFeedback.forEach(feedback => {\n      const theme = themeMap[feedback.id];\n      if (theme) personaThemes.add(theme);\n    });\n    \n    // Connect persona to each theme\n    themeNodes.forEach(theme => {\n      const themeName = theme.name;\n      if (personaThemes.has(themeName)) {\n        links.push({\n          id: uuidv4(),\n          source: persona.id,\n          target: theme.id,\n          strength: 0.6 // Slightly weaker connection\n        });\n      }\n    });\n  });\n  \n  return links;\n};\n\n/**\n * Generate comprehensive analytics from feedback data\n */\nconst generateAnalytics = (feedbackData, themeMap, sentimentMap) => {\n  // Overall sentiment distribution\n  const sentimentCounts = { Positive: 0, Negative: 0, Neutral: 0 };\n  Object.values(sentimentMap).forEach(sentiment => {\n    sentimentCounts[sentiment]++;\n  });\n  \n  // Theme distribution\n  const themeCounts = {};\n  Object.values(themeMap).forEach(theme => {\n    themeCounts[theme] = (themeCounts[theme] || 0) + 1;\n  });\n  \n  // Sentiment by theme\n  const sentimentByTheme = {};\n  feedbackData.forEach(feedback => {\n    const theme = themeMap[feedback.id];\n    const sentiment = sentimentMap[feedback.id];\n    \n    if (!theme || !sentiment) return;\n    \n    if (!sentimentByTheme[theme]) {\n      sentimentByTheme[theme] = { Positive: 0, Negative: 0, Neutral: 0 };\n    }\n    \n    sentimentByTheme[theme][sentiment]++;\n  });\n  \n  // User role distribution\n  const roleCounts = {};\n  feedbackData.forEach(feedback => {\n    if (feedback.user_role) {\n      roleCounts[feedback.user_role] = (roleCounts[feedback.user_role] || 0) + 1;\n    }\n  });\n  \n  // Sentiment by user role\n  const sentimentByRole = {};\n  feedbackData.forEach(feedback => {\n    const role = feedback.user_role;\n    const sentiment = sentimentMap[feedback.id];\n    \n    if (!role || !sentiment) return;\n    \n    if (!sentimentByRole[role]) {\n      sentimentByRole[role] = { Positive: 0, Negative: 0, Neutral: 0 };\n    }\n    \n    sentimentByRole[role][sentiment]++;\n  });\n  \n  // Feedback over time (if timestamp is available)\n  const feedbackByDate = {};\n  feedbackData.forEach(feedback => {\n    if (feedback.timestamp) {\n      const date = new Date(feedback.timestamp).toISOString().split('T')[0];\n      feedbackByDate[date] = (feedbackByDate[date] || 0) + 1;\n    }\n  });\n  \n  return {\n    totalFeedback: feedbackData.length,\n    sentimentDistribution: sentimentCounts,\n    themeDistribution: themeCounts,\n    sentimentByTheme,\n    roleDistribution: roleCounts,\n    sentimentByRole,\n    feedbackByDate\n  };\n};\n\n/**\n * Generate AI insights from feedback\n */\nconst generateInsights = async (feedbackData, themes, themeMap, sentimentMap) => {\n  const insights = [];\n  \n  // Create a map of themes to feedback\n  const themeToFeedback = {};\n  feedbackData.forEach(feedback => {\n    const theme = themeMap[feedback.id];\n    if (theme) {\n      if (!themeToFeedback[theme]) {\n        themeToFeedback[theme] = [];\n      }\n      themeToFeedback[theme].push({\n        text: feedback.text,\n        sentiment: sentimentMap[feedback.id] || 'Neutral'\n      });\n    }\n  });\n  \n  // Generate insights for top themes\n  const topThemes = Object.entries(themeToFeedback)\n    .sort((a, b) => b[1].length - a[1].length)\n    .slice(0, 5) // Show more themes\n    .map(([theme]) => theme);\n  \n  // Add overview insight first\n  const sentimentCounts = { Positive: 0, Negative: 0, Neutral: 0 };\n  Object.values(sentimentMap).forEach(sentiment => {\n    sentimentCounts[sentiment]++;\n  });\n  \n  insights.push({\n    id: uuidv4(),\n    title: 'Feedback Overview',\n    description: `Analyzed ${feedbackData.length} pieces of feedback across ${themes.length} key themes. Overall sentiment: ${sentimentCounts.Positive} positive, ${sentimentCounts.Negative} negative, and ${sentimentCounts.Neutral} neutral feedback items.`\n  });\n  \n  for (const theme of topThemes) {\n    const feedbackItems = themeToFeedback[theme];\n    const feedbackCount = feedbackItems.length;\n    \n    // Calculate sentiment distribution for this theme\n    const themeSentiment = { Positive: 0, Negative: 0, Neutral: 0 };\n    feedbackItems.forEach(item => {\n      themeSentiment[item.sentiment]++;\n    });\n    \n    // Find representative examples of both positive and negative feedback\n    const positiveFeedback = feedbackItems.filter(item => item.sentiment === 'Positive')[0]?.text;\n    const negativeFeedback = feedbackItems.filter(item => item.sentiment === 'Negative')[0]?.text;\n    \n    const examples = [];\n    if (positiveFeedback) examples.push(`Positive: \"${truncateText(positiveFeedback, 60)}\"`);\n    if (negativeFeedback) examples.push(`Negative: \"${truncateText(negativeFeedback, 60)}\"`);\n    \n    const sentimentSummary = `Sentiment: ${themeSentiment.Positive} positive, ${themeSentiment.Negative} negative, ${themeSentiment.Neutral} neutral`;\n    \n    // Add theme-specific insight with sentiment analysis\n    insights.push({\n      id: uuidv4(),\n      title: `${theme}`,\n      description: `${feedbackCount} feedback items were identified in this theme. ${sentimentSummary}. ${examples.length > 0 ? 'Examples include: ' + examples.join('; ') : ''}`,\n      sentiment: themeSentiment,\n      feedbackCount\n    });\n  }\n  \n  // Add role-based insight\n  const roles = [...new Set(feedbackData.map(item => item.user_role).filter(Boolean))];\n  if (roles.length > 0) {\n    // Calculate sentiment by role\n    const sentimentByRole = {};\n    feedbackData.forEach(feedback => {\n      const role = feedback.user_role;\n      const sentiment = sentimentMap[feedback.id];\n      \n      if (!role || !sentiment) return;\n      \n      if (!sentimentByRole[role]) {\n        sentimentByRole[role] = { Positive: 0, Negative: 0, Neutral: 0 };\n      }\n      \n      sentimentByRole[role][sentiment]++;\n    });\n    \n    // Find the role with the most negative sentiment\n    let mostNegativeRole = '';\n    let highestNegativePercentage = 0;\n    \n    Object.entries(sentimentByRole).forEach(([role, counts]) => {\n      const total = counts.Positive + counts.Negative + counts.Neutral;\n      const negativePercentage = counts.Negative / total;\n      \n      if (negativePercentage > highestNegativePercentage) {\n        highestNegativePercentage = negativePercentage;\n        mostNegativeRole = role;\n      }\n    });\n    \n    insights.push({\n      id: uuidv4(),\n      title: 'User Role Analysis',\n      description: `Feedback came from ${roles.length} different user roles. ${mostNegativeRole ? `${mostNegativeRole} users expressed the most concerns, with ${Math.round(highestNegativePercentage * 100)}% negative feedback.` : ''}`\n    });\n  }\n  \n  return insights;\n};\n\n/**\n * Helper function to truncate text\n */\nconst truncateText = (text, maxLength) => {\n  if (!text) return \"No text\";\n  if (text.length <= maxLength) return text;\n  \n  // For longer texts, try to find a good breaking point\n  const breakPoint = text.lastIndexOf(' ', maxLength - 3);\n  if (breakPoint > maxLength / 2) {\n    return text.substring(0, breakPoint) + '...';\n  }\n  return text.substring(0, maxLength) + '...';\n};\n\n/**\n * Import and process JSON feedback data\n * @param {File|String} source - Either a File object or a JSON string\n * @returns {Promise} Promise that resolves to processed data\n */\nexport const importFeedbackData = async (source) => {\n  try {\n    let data;\n    \n    if (typeof source === 'string') {\n      // If the source is a JSON string\n      data = JSON.parse(source);\n    } else if (source instanceof File) {\n      // If the source is a File object\n      const text = await readFileAsText(source);\n      data = JSON.parse(text);\n    } else {\n      throw new Error('Invalid source type. Expected File or JSON string.');\n    }\n    \n    // If the data is not an array but has a property that is an array\n    if (!Array.isArray(data)) {\n      // Look for a property that might contain the feedback array\n      const possibleArrayProps = Object.keys(data).filter(key => Array.isArray(data[key]));\n      \n      if (possibleArrayProps.length > 0) {\n        data = data[possibleArrayProps[0]];\n      } else {\n        throw new Error('Could not find feedback data array in the imported JSON.');\n      }\n    }\n    \n    // Process the data with AI classification\n    return await processFeedbackData(data);\n  } catch (error) {\n    console.error('Error importing feedback data:', error);\n    throw error;\n  }\n};\n\n/**\n * Read a file as text\n */\nconst readFileAsText = (file) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result);\n    reader.onerror = reject;\n    reader.readAsText(file);\n  });\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}